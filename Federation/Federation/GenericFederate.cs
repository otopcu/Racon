// ***************************************************************************
//                          RACoN.Federate
//		begin                : Jul 17, 2009
// ***************************************************************************

/* 
RACoN - RTI abstraction component for MS.NET (RACoN)
https://sites.google.com/site/okantopcu/racon

Copyright © Okan Topçu, 2009-2017
otot.support@outlook.com

This program is free software : you can redistribute it and / or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;//BackgroundWorker
using System.Diagnostics.Contracts;
using System.Linq;//.ToList()
// RACoN
using Racon.ObjectModel;
using Racon.RtiLayer;
using Racon.RtiLayer.Native;
using Racon.Logger;

namespace Racon
{
  /// <summary>
  /// Presents an extension point for application-specific federates. The generic federate defines the abstraction and is implemented as a wrapper façade class. 
  /// </summary>
  /// <remarks>
  /// <para> This class is the base wrapper for the RTI-specific classes (i.e. the RTI Layer) and the main extension point. This class should be inherited by a class that encapsulates the federate-specific data.</para>
  /// <para> Most federate developers (mainly students or inexperienced simulation developers) are not interested in the details of this subsystem, which complicate their implementation; instead their only need is to initialize the federation ex-ecution. Hence, the generic federate provides a higher-level interface. The developer calls only the method (InitializeFederation) rather than calling related series of low-level RTI methods (such as; create federation, join federation, create regions, and publish and subscribe classes). One of the rationales here is to simplify the interface for novice HLA users by hiding the perplexing RTI class relationships. On the other hand, the low-level RTI methods can still be called using the CRtiAmb.</para>
  /// <para>RACoN provides notifications about HLA-related services to the application-specific federate by using events (event-based notification). Therefore, an application-specific federate can handle events triggered from the commu-nication layer by overriding the event handlers that are subscribed by the base federate in order to customize their RTI-related behaviors (delegated event handling). For example, when a new object is discovered, the RACoN assembly raises a new object discovered event. The application-specific fed-erate that hooks the event, is notified that the event has been triggered. Then, the application-specific federate can take action such as adding the new ob-ject to its scene graph or creating a local substitute for that object. .NET event handling structures are used for implementing events and event handling mechanisms. Events are categorized according to their initiators, as follows: </para>
  /// <list type="bullet">
  /// <item>RTI-initiated events generated by federate ambassador callbacks such as an object discovered event. </item>
  /// <item>Federate-initiated events generated by the RTI ambassador such as a federate joined event. </item>
  /// <item>RACoN events generated by the generic federate such as a feder-ate state changed event.</item>
  /// </list>
  /// <para>The federate-initiated and RACON event handlers are executed as soon as they are raised, but, the RTI-initiated events (callbacks from the RTI to the federate ambassador) are queued as events for processing at the end of each simulation cycle. They are executed when the federate run method is called. The federate Run() method must be called in the main (simulation loop) of the application.</para>
  /// </remarks>
  public abstract class CGenericFederate : CallbackManager, IDisposable
  {
    #region Fields
    private RtiAmb _rtiAmb; // Generic RTI Ambassador
    private RTILibraryType _RtiLibrary; // Current RTI Library reference
    private CObjectModel _som;
    private FederateStates _FederateState;
    private FederationExecutionStates _FederationExecutionState;
    // Loggers
    private string _statusMessage;
    private LogManager logger;
    #endregion // Fields

    #region Properties
    /// <summary>
    /// The reference for internal RTI ambassador. This reference can be used to access internal RTI ambassador interface
    /// </summary>
    protected RtiAmb RtiAmb
    {
      get { return _rtiAmb; }
    }

    /// <summary>
    /// Current federate state. When it is set, it raises <see cref="Racon.CGenericFederate.FederateStateChanged"/> Event.
    /// </summary>
    public FederateStates FederateState
    {
      get { return _FederateState; }
      set
      {
        _FederateState = value;
        OnFederateStateChanged(new CFederateStateEventArgs(_FederateState));
        //StatusMessage = "Federate State: " + _FederateState.ToString();
        logger.Add("Federate State: " + _FederateState.ToString(), LogLevel.INFO);
      }
    }

    /// <summary>
    /// Current federation execution state. When it is set, it raises <see cref="Racon.CGenericFederate.FederationStateChanged"/> Event.
    /// </summary>
    public FederationExecutionStates FederationExecutionState
    {
      get { return _FederationExecutionState; }
      private set // Only RACoN assemblies can set 
      {
        _FederationExecutionState = value;
        OnFederationStateChanged(new CFederationStateEventArgs(_FederationExecutionState));
        logger.Add("Federation State: " + _FederationExecutionState.ToString(), LogLevel.INFO);
      }
    }

    /// <summary>
    /// The log message RACoN. When it is set, it raises <see cref="Racon.CGenericFederate.StatusMessageChanged"/> Event.
    /// </summary>
    public string StatusMessage
    {
      get { return _statusMessage; }
      private set
      {
        _statusMessage = value;
        // Raise the status changed event
        if (LogLevel != LogLevel.OFF)
        {
          OnStatusMessageChanged();
        }
      }
    }

    /// <summary>
    /// TraceLog dumbs the logger.Log
    /// </summary>
    public string TraceLog
    {
      get
      {
        return logger.ToString();
      }
    }

    /// <summary>
    /// Current Log Level. When it is set, it reports version, RTI native library, and current log level via <see cref="Racon.CGenericFederate.StatusMessage"/>. 
    /// </summary>
    public LogLevel LogLevel
    {
      get { return logger.LogLevel; }
      set
      {
        logger.LogLevel = value;
        // report initialization state
        logger.Add("RACoN RTI library used: " + RTILibrary.ToString(), LogLevel.INFO);
        logger.Add("Native RTI library: " + _rtiAmb.RtiVersion, LogLevel.INFO);
        logger.Add("Federate State: " + FederateState.ToString(), LogLevel.INFO);
        logger.Add("Federation State: " + _FederationExecutionState.ToString(), LogLevel.INFO);
      }
    }

    /// <summary>
    /// Current type of native RTI Library. It is set via constructor only, <see cref="Racon.CGenericFederate.RtiAmb"/> switches accordingly.
    /// </summary>
    public RTILibraryType RTILibrary
    {
      get { return _RtiLibrary; }
      private set
      {
        _RtiLibrary = value;
        switch (_RtiLibrary)
        {
          case RTILibraryType.HLA13_DMSO:
            _rtiAmb = new RtiAmb_Dmso_Hla13(this);
            break;
          case RTILibraryType.HLA13_Portico:
            _rtiAmb = new RtiAmb_Portico_Hla13(this);
            break;
          case RTILibraryType.HLA13_OpenRti:
            _rtiAmb = new RtiAmb_OpenRti_Hla13(this);
            break;
          case RTILibraryType.HLA1516e_Portico:
            _rtiAmb = new RtiAmb_OpenRti_1516e(this);
            break;
          case RTILibraryType.HLA1516e_OpenRti:
            _rtiAmb = new RtiAmb_OpenRti_1516e(this);
            break;
          default:
            break;
        }
      }
    }

    /// <summary>
    /// The federation execution that this federate will interact (e.g. create, join etc.).
    /// </summary>
    public CFederationExecution FederationExecution { get; set; }

    /// <summary>
    /// Federate handle.
    /// </summary>
    public uint FederateHandle { get; set; }

    /// <summary>
    /// The federate logical time. A point in HLA time axis.
    /// </summary>
    public double Time { get; set; }

    /// <summary>
    /// The federate lookahead. Time interval
    /// </summary>
    public double Lookahead { get; set; }

    #endregion // Properties

    #region Delegates
    //public delegate void FederateStateChangedHandler(object sender, CFederateStateEventArgs fe);
    #endregion // Delegates (function pointers)

    #region Events
    /// <summary>
    /// Log message change event.
    /// </summary>
    public event EventHandler StatusMessageChanged;
    /// <summary>
    /// Federate state change event.
    /// </summary>
    public event EventHandler<CFederateStateEventArgs> FederateStateChanged;
    /// <summary>
    /// Federation state change event.
    /// </summary>
    public event EventHandler<CFederationStateEventArgs> FederationStateChanged;
    #endregion // Events

    #region EventRaisers
    /// <summary>
    /// Wraps the event in a protected virtual method to enable derived classes to raise the event.
    /// </summary>
    protected virtual void OnStatusMessageChanged()
    {
      StatusMessageChanged?.Invoke(this, EventArgs.Empty);// Raise the event.
    }

    /// <summary>
    /// Wraps the event in a protected virtual method to enable derived classes to raise the event.
    /// </summary>
    protected virtual void OnFederateStateChanged(CFederateStateEventArgs e)
    {
      FederateStateChanged?.Invoke(this, e);// Raise the event.
    }

    /// <summary>
    /// Wraps the event in a protected virtual method to enable derived classes to raise the event.
    /// </summary>
    protected virtual void OnFederationStateChanged(CFederationStateEventArgs e)
    {
      FederationStateChanged?.Invoke(this, e);// Raise the event.
    }

    #endregion // Event Raisers

    #region Constructors
    /// <summary>
    /// CGenericFederate constructor
    /// </summary>
    /// <param name="rti"> Native RTI library reference. Default is RTILibraryType.HLA1516e_OpenRti</param>
    public CGenericFederate(RTILibraryType rti = RTILibraryType.HLA1516e_OpenRti)
      : base()
    {
      // Set Default RTI
      RTILibrary = rti;
      // Instantiate members
      _som = new CObjectModel();
      FederationExecution = new CFederationExecution();
      // initialize logger
      logger = new LogManager();
      logger.Log.CollectionChanged += Log_ListChanged;
      // Set states
      _FederationExecutionState = FederationExecutionStates.FEDEX_DOESNOTEXIST;
      _FederateState = FederateStates.NOTCONNECTED;
      // initalize time
      Time = 0.0;
      Lookahead = 0.0;
      // Subscribe to the Contract Failed Event for Pre- and post conditions
      Contract.ContractFailed += Contract_ContractFailed;
      // Subscribe to the HLA-specific service events (RACoN Events + RTI Events + Federate Events)
      _rtiAmb.NoConnection += RtiAmb_NotConnected;
      _rtiAmb.FederateConnected += RtiAmb_FederateConnected;
      _rtiAmb.FederateDisconnected += RtiAmb_FederateDisconnected; ;
      _rtiAmb.FederateJoined += RtiAmb_FederateJoined;
      _rtiAmb.FederateResigned += RtiAmb_FederateResigned;
      _rtiAmb.FederationExecutionCreated += RtiAmb_FederationExecutionCreated;
      _rtiAmb.FederationExecutionDestroyed += RtiAmb_FederationExecutionDestroyed;
      _rtiAmb.ObjectRegistered += RtiAmb_ObjectRegistered;
      _rtiAmb.HLAClassPublished += RtiAmb_HLAClassPublished;
      _rtiAmb.HLAClassSubscribed += RtiAmb_HLAClassSubscribed;
      _rtiAmb.RTIEventOccured += RtiAmb_RTIEventOccured;
      // FM
      ConnectionLost += FdAmb_ConnectionLost;
      FederationExecutionsReported += FdAmb_FederationExecutionsReported;
      SynchronizationPointRegistrationSucceeded += FdAmb_OnSynchronizationPointRegistrationConfirmedHandler;
      SynchronizationPointRegistrationFailed += FdAmb_OnSynchronizationPointRegistrationFailedHandler;
      SynchronizationPointAnnounced += FdAmb_SynchronizationPointAnnounced;
      FederationSynchronized += FdAmb_FederationSynchronized;
      InitiateFederateSave += FdAmb_InitiateFederateSaveHandler;
      InitiateFederateRestore += FdAmb_InitiateFederateRestoreHandler;
      FederationRestorationRequestConfirmed += FdAmb_ConfirmFederationRestorationRequestHandler;
      FederationRestored += FdAmb_FederationRestored;
      FederationSaved += FdAmb_FederationSaved;
      FederationRestoreBegun += FdAmb_FederationRestoreBegun;
      // DM
      StartRegistrationForObjectClassAdvised += FdAmb_StartRegistrationForObjectClassAdvisedHandler;
      StopRegistrationForObjectClassAdvised += FdAmb_StopRegistrationForObjectClassAdvisedHandler;
      TurnInteractionsOffAdvised += FdAmb_TurnInteractionsOffAdvisedHandler;
      TurnInteractionsOnAdvised += FdAmb_TurnInteractionsOnAdvisedHandler;
      // OM
      ObjectDiscovered += FdAmb_ObjectDiscoveredHandler;
      ObjectRemoved += FdAmb_ObjectRemovedHandler;
      ObjectAttributesReflected += FdAmb_ObjectAttributesReflectedHandler;
      InteractionReceived += FdAmb_InteractionReceivedHandler;
      AttributeValueUpdateRequested += FdAmb_AttributeValueUpdateRequestedHandler;
      // OwM
      AttributeOwnershipReleaseRequested += FdAmb_AttributeOwnershipReleaseRequestedHandler;
      AttributeOwnershipInformed += FdAmb_AttributeOwnershipInformed;
      AttributeOwnershipAcquisitionNotified += FdAmb_AttributeOwnershipAcquisitionNotified;
      AttributeOwnershipDivestitureNotified += FdAmb_AttributeOwnershipDivestitureNotified;
      AttributeOwnershipUnavailable += FdAmb_AttributeOwnershipUnavailable;
      AttributeOwnershipAcquisitionCancellationConfirmed += FdAmb_AttributeOwnershipAcquisitionCancellationConfirmed;
      AttributeOwnershipAssumptionRequested += FdAmb_AttributeOwnershipAssumptionRequested;
      // TM
      TimeConstrainedEnabled += FdAmb_TimeConstrainedEnabled;
      TimeRegulationEnabled += FdAmb_TimeRegulationEnabled;
      TimeAdvanceGrant += FdAmb_TimeAdvanceGrant;
      RequestRetraction += FdAmb_RequestRetraction;

      // Start the federate clock
      //FederateClock.StartClock();
      //backgroundWorker1.DoWork += new DoWorkEventHandler(FdAmb_ObjectAttributesReflected);
      //backgroundWorker1.RunWorkerCompleted += new RunWorkerCompletedEventHandler(FdAmb_ObjectAttributesReflected);
    }
    #endregion // Constructors

    #region Finalizer
    /// <summary>
    /// CGenericFederate destructor disposes 
    /// </summary>
    public void Dispose()
    {
      Dispose(true);
      GC.SuppressFinalize(this);
    }
    /// <summary>
    /// Dispose(bool disposing) 
    /// </summary>
    protected virtual void Dispose(bool disposing)
    {
      if (disposing)
      {
        IDisposable dis = RtiAmb as IDisposable;
        if (dis != null) { dis.Dispose(); }
      }
    }
    #endregion 

    #region Event Handlers

    #region FdAmb Callback Event Handlers
    #region FM handlers
    /// <summary>
    /// IEEE1516.1-2010 4.4: Connection Lost
    /// </summary>
    public virtual void FdAmb_ConnectionLost(object sender, HlaFederationManagementEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
      // In case of RTI crash - resign and disconnect
      bool res = ResignFederationExecution();
      if (res) Disconnect();
    }
    /// <summary>
    /// IEEE1516.1-2010 4.8: Federation Executions Reported. Federate ambassador callback to get the federation executions
    /// </summary>
    public virtual void FdAmb_FederationExecutionsReported(object sender, HlaFederationManagementEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
    }
    /// <summary>
    /// IEEE1516.1-2010 4.12a: FdAmb_OnSynchronizationPointRegistrationConfirmedHandler
    /// </summary>
    public virtual void FdAmb_OnSynchronizationPointRegistrationConfirmedHandler(object sender, HlaFederationManagementEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
    }
    /// <summary>
    /// IEEE1516.1-2010 4.12b: FdAmb_OnSynchronizationPointRegistrationFailedHandler
    /// </summary>
    public virtual void FdAmb_OnSynchronizationPointRegistrationFailedHandler(object sender, HlaFederationManagementEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
    }
    /// <summary>
    /// IEEE1516.1-2010 4.13: Federate ambassador callback. FdAmb_SynchronizationPointAnnounced.
    /// </summary>
    public virtual void FdAmb_SynchronizationPointAnnounced(object sender, HlaFederationManagementEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
    }
    /// <summary>
    /// IEEE1516.1-2010 4.15: Federate ambassador callback. FdAmb_FederationSynchronized
    /// </summary>
    public virtual void FdAmb_FederationSynchronized(object sender, HlaFederationManagementEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
    }
    /// <summary>
    /// IEEE1516.1-2010 4.17: Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_InitiateFederateSaveHandler(object sender, HlaFederationManagementEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
    }
    /// <summary>
    /// IEEE1516.1-2010 4.20: Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_FederationSaved(object sender, HlaFederationManagementEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
    }
    /// <summary>
    /// IEEE1516.1-2010 4.22: FdAmb_FederationSaveStatusResponse
    /// </summary>
    public virtual void FdAmb_FederationSaveStatusResponse(object sender, HlaFederationManagementEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
    }
    /// <summary>
    /// IEEE1516.1-2010 4.25: Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_ConfirmFederationRestorationRequestHandler(object sender, HlaFederationManagementEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
    }
    /// <summary>
    /// IEEE1516.1-2010 4.26: Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_FederationRestoreBegun(object sender, HlaFederationManagementEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
    }
    /// <summary>
    /// IEEE1516.1-2010 4.27: Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_InitiateFederateRestoreHandler(object sender, HlaFederationManagementEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
    }
    /// <summary>
    /// IEEE1516.1-2010 4.29: Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_FederationRestored(object sender, HlaFederationManagementEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
    }
    /// <summary>
    /// IEEE1516.1-2010 4.32: FdAmb_FederationRestoreStatusResponse
    /// </summary>
    public virtual void FdAmb_FederationRestoreStatusResponse(object sender, HlaFederationManagementEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
    }
    #endregion // FM Handlers
    #region DM handlers
    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_StartRegistrationForObjectClassAdvisedHandler(object sender, HlaDeclarationManagementEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
    }

    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_StopRegistrationForObjectClassAdvisedHandler(object sender, HlaDeclarationManagementEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
    }

    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_TurnInteractionsOffAdvisedHandler(object sender, HlaDeclarationManagementEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
    }

    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_TurnInteractionsOnAdvisedHandler(object sender, HlaDeclarationManagementEventArgs data)
    {

      logger.Add(data.TraceMessage, data.Level);
    }
    #endregion // DM Handlers
    #region OM handlers
    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_ObjectDiscoveredHandler(object sender, HlaObjectEventArgs data)
    {
      //// Multiple parameter passing - Example
      //ThreadStart starter = delegate { FdAmb_ObjectDiscovered(sender, data); };
      //new Thread(starter).Start();

      //// Only one parameter passing
      //Thread thread = new Thread(new ParameterizedThreadStart(FdAmb_ObjectDiscovered));
      //thread.Start(data);

      logger.Add(data.TraceMessage, data.Level);
    }

    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_ObjectRemovedHandler(object sender, HlaObjectEventArgs data)
    {

      logger.Add(data.TraceMessage, data.Level);
    }

    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_AttributeValueUpdateRequestedHandler(object sender, HlaObjectEventArgs data)
    {

      logger.Add(data.TraceMessage, data.Level);
    }

    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_InteractionReceivedHandler(object sender, HlaInteractionEventArgs data)
    {

      logger.Add(data.TraceMessage, data.Level);
    }

    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_ObjectAttributesReflectedHandler(object sender, HlaObjectEventArgs data)
    {

      logger.Add(data.TraceMessage, data.Level);
    }

    /// <summary>
    /// Federate ambassador callback - TurnUpdatesOnForObjectInstance
    /// </summary>
    public virtual void FdAmb_TurnUpdatesOnForObjectInstanceAdvisedHandler(object sender, HlaObjectEventArgs data)
    {

      logger.Add(data.TraceMessage, data.Level);
    }
    /// <summary>
    /// Federate ambassador callback - TurnUpdatesOffForObjectInstance
    /// </summary>
    public virtual void FdAmb_TurnUpdatesOffForObjectInstanceAdvisedHandler(object sender, HlaObjectEventArgs data)
    {

      logger.Add(data.TraceMessage, data.Level);
    }
    #endregion // OM Handlers
    #region OwM handlers

    /// <summary>
    /// IEEE1516-2010 7.4
    /// FdAmb_AttributeOwnershipAssumptionRequested
    /// </summary>
    public virtual void FdAmb_AttributeOwnershipAssumptionRequested(object sender, HlaOwnershipManagementEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
    }

    /// <summary>
    /// IEEE1516-2010 7.5
    /// </summary>
    public virtual void FdAmb_RequestDivestitureConfirmation(object sender, HlaOwnershipManagementEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
    }

    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_AttributeOwnershipAcquisitionCancellationConfirmed(object sender, HlaOwnershipManagementEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
    }

    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_AttributeOwnershipUnavailable(object sender, HlaOwnershipManagementEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
    }

    /// <summary>
    /// Federate ambassador callback // HLA13 only
    /// </summary>
    public virtual void FdAmb_AttributeOwnershipDivestitureNotified(object sender, HlaOwnershipManagementEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
    }

    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_AttributeOwnershipAcquisitionNotified(object sender, HlaOwnershipManagementEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
    }

    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_AttributeOwnershipInformed(object sender, HlaOwnershipManagementEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
    }

    /// <summary>
    /// Federate ambassador callback - HLA13 only
    /// </summary>
    public virtual void FdAmb_AttributeOwnershipReleaseRequestedHandler(object sender, HlaOwnershipManagementEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
    }
    #endregion // OwM Handlers
    #region TM handlers
    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_TimeConstrainedEnabled(object sender, HlaTimeManagementEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
    }
    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_TimeRegulationEnabled(object sender, HlaTimeManagementEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
    }
    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_TimeAdvanceGrant(object sender, HlaTimeManagementEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
    }
    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_RequestRetraction(object sender, HlaTimeManagementEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
    }
    #endregion // TM Handlers
    #endregion // RTI-initiated Callback Event Handlers

    #region RtiAmb Handlers

    /// <summary>
    /// RTI ambassador handler for RtiAmb_FederateConnected
    /// </summary>
    private void RtiAmb_NotConnected(object sender, RaconEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
      FederateState = FederateStates.NOTCONNECTED;
    }

    /// <summary>
    /// RTI ambassador handler for RtiAmb_FederateConnected
    /// </summary>
    private void RtiAmb_FederateConnected(object sender, RaconEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
      FederateState = FederateStates.CONNECTED | FederateStates.NOTJOINED;
    }

    /// <summary>
    /// RTI ambassador handler for RtiAmb_FederateDisconnected
    /// </summary>
    private void RtiAmb_FederateDisconnected(object sender, RaconEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
      FederateState = FederateStates.NOTCONNECTED;
    }

    /// <summary>
    /// RTI ambassador handler for RtiAmb_FederateJoined
    /// </summary>
    public virtual void RtiAmb_FederateJoined(object sender, RaconEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
      FederateState = FederateStates.CONNECTED | FederateStates.JOINED | FederateStates.FREERUN;
    }

    /// <summary>
    /// RTI ambassador handler for RtiAmb_FederateResigned
    /// </summary>
    public virtual void RtiAmb_FederateResigned(object sender, RaconEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
      FederateState = FederateStates.CONNECTED | FederateStates.NOTJOINED;
    }

    /// <summary>
    /// RTI ambassador handler for RtiAmb_FederationExecutionCreated
    /// </summary>
    public virtual void RtiAmb_FederationExecutionCreated(object sender, RaconEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
      FederationExecutionState = FederationExecutionStates.FEDEX_EXISTS;
    }

    /// <summary>
    /// RTI ambassador handler for RtiAmb_FederationExecutionDestroyed
    /// </summary>
    public virtual void RtiAmb_FederationExecutionDestroyed(object sender, RaconEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
      FederationExecutionState = FederationExecutionStates.FEDEX_DOESNOTEXIST;
    }

    /// <summary>
    /// RTI ambassador handler for RtiAmb_ObjectRegistered
    /// </summary>
    public virtual void RtiAmb_ObjectRegistered(object sender, RaconEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
    }

    /// <summary>
    /// RTI ambassador handler for RtiAmb_HLAClassPublished
    /// </summary>
    public virtual void RtiAmb_HLAClassPublished(object sender, RaconEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
    }

    /// <summary>
    /// RTI ambassador handler for RtiAmb_HLAClassSubscribed
    /// </summary>
    public virtual void RtiAmb_HLAClassSubscribed(object sender, RaconEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
    }

    /// <summary>
    /// RTI ambassador handler for RtiAmb_RTIEventOccured
    /// </summary>
    public virtual void RtiAmb_RTIEventOccured(object sender, RaconEventArgs data)
    {
      logger.Add(data.TraceMessage, data.Level);
    }
    #endregion // RTIAmb Handlers

    #region Contract Handlers
    /// <summary>
    ///Contract handler
    /// </summary>
    private void Contract_ContractFailed(object sender, ContractFailedEventArgs data)
    {
      logger.Add("Contract Failed: " + data.Message, LogLevel.WARN);
      data.SetHandled();
    }
    #endregion // Contract Handlers

    #region Logger Handlers
    /// <summary>
    /// Whenever a new log entry happens, this is used to check to report the message according to log level
    /// </summary>
    private void Log_ListChanged(object sender, NotifyCollectionChangedEventArgs e)
    {
      // CREATE
      if (e.NewItems != null && e.NewItems.Count != 0)
        foreach (LogEntry node in e.NewItems)
        {
          // Report message according to Log Level
          if (node.Level >= logger.LogLevel)
            StatusMessage = node.Message;
        }
    }
    #endregion

    #endregion // Event Handlers

    #region Methods

    #region High-Level Services

    /// <summary>
    /// Method to tick and process the callbacks.
    /// </summary>
    /// <remarks>This method is called to tick and process the callbacks. Typically, it is called in main simuation loop.
    /// </remarks>
    virtual public void Run()
    {
      EvokeCallback();
      #region Process the FdAmb Event Queues
      while (FdAmbEventQueue.Count != 0)
      {
        //StatusMessage = "Queue Count = " + FdAmbEventQueue.Count;
        RaconEventArgs AnEventInstance = FdAmbEventQueue.Dequeue();
        //StatusMessage = "Event Type = " + AnEventInstance.EventType;
        switch (AnEventInstance.EventType)
        {
          #region FM
          case RaconEventTypes.ConnectionLost:
            OnConnectionLost((HlaFederationManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.FederationExecutionsReported:
            OnFederationExecutionsReported((HlaFederationManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.SynchronizationPointRegistrationSucceeded:
            OnSynchronizationPointRegistrationConfirmed((HlaFederationManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.synchronizationPointRegistrationFailed:
            OnSynchronizationPointRegistrationFailed((HlaFederationManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.SynchronizationPointAnnounced:
            OnSynchronizationPointAnnounced((HlaFederationManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.FederationSynchronized:
            OnFederationSynchronized((HlaFederationManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.InitiateFederateSave:
            OnInitiateFederateSave((HlaFederationManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.InitiateFederateRestore:
            OnInitiateFederateRestore((HlaFederationManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.FederationRestorationRequestConfirmed:
            OnFederationRestorationRequestConfirmed((HlaFederationManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.FederationSaved:
            OnFederationSaved((HlaFederationManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.FederationRestored:
            OnFederationRestored((HlaFederationManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.FederationRestoreBegun:
            OnFederationRestoreBegun((HlaFederationManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.FederationSaveStatusResponse:
            OnFederationSaveStatusResponse((HlaFederationManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.FederationRestoreStatusResponse:
            OnFederationRestoreStatusResponse((HlaFederationManagementEventArgs)AnEventInstance);
            break;
          #endregion
          #region DM
          case RaconEventTypes.StartRegistrationForObjectClassAdvised:
            OnStartRegistrationForObjectClassAdvised((HlaDeclarationManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.StopRegistrationForObjectClassAdvised:
            OnStopRegistrationForObjectClassAdvised((HlaDeclarationManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.TurnInteractionsOffAdvised:
            OnTurnInteractionsOffAdvised((HlaDeclarationManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.TurnInteractionsOnAdvised:
            OnTurnInteractionsOnAdvised((HlaDeclarationManagementEventArgs)AnEventInstance);
            break;
          #endregion
          #region OM
          case RaconEventTypes.ObjectDiscovered:
            OnObjectDiscovered((HlaObjectEventArgs)AnEventInstance);
            //StatusMessage = "here-1";
            break;
          case RaconEventTypes.ObjectRemoved:
            HlaObjectEventArgs args = (HlaObjectEventArgs)AnEventInstance;
            OnObjectRemoved(args);
            args.Tag.FreeIntPtrMemory(); // free tag
            break;
          case RaconEventTypes.InteractionReceived:
            HlaInteractionEventArgs interactionArgs = (HlaInteractionEventArgs)AnEventInstance;
            OnInteractionReceived(interactionArgs);
            foreach (var obj in interactionArgs.Interaction.Parameters)
              obj.FreeIntPtrMemory();
            interactionArgs.Tag.FreeIntPtrMemory(); // Free tag
            break;
          case RaconEventTypes.AttributeValueUpdateRequested:
            HlaObjectEventArgs args2 = (HlaObjectEventArgs)AnEventInstance;
            OnAttributeValueUpdateRequested(args2);
            args2.Tag.FreeIntPtrMemory(); // Free tag
            break;
          case RaconEventTypes.ObjectAttributesReflected:
            HlaObjectEventArgs args3 = (HlaObjectEventArgs)AnEventInstance;
            OnObjectAttributesReflected(args3);
            foreach (var attr in args3.ObjectInstance.Attributes)
              attr.FreeIntPtrMemory();
            args3.Tag.FreeIntPtrMemory(); // Free tag
            break;
          case RaconEventTypes.TurnUpdatesOnForObjectInstanceAdvised:
            OnTurnUpdatesOnForObjectInstanceAdvised((HlaObjectEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.TurnUpdatesOffForObjectInstanceAdvised:
            OnTurnUpdatesOffForObjectInstanceAdvised((HlaObjectEventArgs)AnEventInstance);
            break;
          #endregion
          #region OwM
          case RaconEventTypes.RequestDivestitureConfirmation:
            OnRequestDivestitureConfirmation((HlaOwnershipManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.AttributeOwnershipAssumptionRequested:
            HlaOwnershipManagementEventArgs args5 = (HlaOwnershipManagementEventArgs)AnEventInstance;
            OnAttributeOwnershipAssumptionRequested(args5);
            args5.Tag.FreeIntPtrMemory(); // Free tag
            break;
          case RaconEventTypes.AttributeOwnershipAcquisitionCancellationConfirmed:
            OnAttributeOwnershipAcquisitionCancellationConfirmed((HlaOwnershipManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.AttributeOwnershipUnavailable:
            OnAttributeOwnershipUnavailable((HlaOwnershipManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.AttributeOwnershipAcquisitionNotified:
            HlaOwnershipManagementEventArgs args4 = (HlaOwnershipManagementEventArgs)AnEventInstance;
            OnAttributeOwnershipAcquisitionNotified(args4);
            args4.Tag.FreeIntPtrMemory(); // Free tag
            break;
          case RaconEventTypes.AttributeOwnershipDivestitureNotified:
            OnAttributeOwnershipDivestitureNotified((HlaOwnershipManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.AttributeOwnershipReleaseRequested:
            HlaOwnershipManagementEventArgs args6 = (HlaOwnershipManagementEventArgs)AnEventInstance;
            OnAttributeOwnershipReleaseRequested(args6);
            args6.Tag.FreeIntPtrMemory(); // Free tag
            break;
          case RaconEventTypes.AttributeOwnershipInformed:
            OnAttributeOwnershipInformed((HlaOwnershipManagementEventArgs)AnEventInstance);
            break;
          #endregion
          #region TM
          // TM
          case RaconEventTypes.TimeConstrainedEnabled:
            OnTimeConstrainedEnabled((HlaTimeManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.TimeRegulationEnabled:
            OnTimeRegulationEnabled((HlaTimeManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.TimeAdvanceGrant:
            OnTimeAdvanceGrant((HlaTimeManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.RequestRetraction:
            OnRequestRetraction((HlaTimeManagementEventArgs)AnEventInstance);
            break;
          default: // just log
            logger.Add(AnEventInstance.TraceMessage, AnEventInstance.Level);
            break;
            #endregion
        }
      }
      #endregion
    }

    /// <summary>
    /// Sets the simulation object model for federate.
    /// </summary>
    /// <param name="objectModel">Object Model</param>
    /// <returns>True if method call is succesfull.</returns>
    virtual public bool SetSom(CObjectModel objectModel)
    {
      _som = objectModel;
      _som.RtiAmb = _rtiAmb;
      //// Object Classes
      //foreach (HlaObjectClass oc in objectModel.OCList)
      //  _som.AddToObjectModel(oc);
      //// Interaction Classes
      //foreach (HlaInteractionClass ic in objectModel.ICList)
      //  _som.AddToObjectModel(ic);
      //// Routing Spaces
      //foreach (CRoutingSpace rs in objectModel.RSList)
      //  _som.AddToObjectModel(rs);

      //_som.RtiAmb = objectModel.RtiAmb;

      return true;
    }

    /// <summary>
    /// Initializes federation execution:
    /// (1) Connects.
    /// (2) Creates federation execution.
    /// (3) Joins federation execution.
    /// (4) Creates regions.
    /// (5) Declares capability.
    /// </summary>
    /// <param name="fedexec">Federation Execution</param>
    /// <returns>returns True/False.</returns>
    /// <remarks>High level interface. This method creates federation if it is first one, joins federation, creates regions, and publishes and subscribes classes.
    /// </remarks>
    virtual public bool InitializeFederation(CFederationExecution fedexec)
    {
      // fedexec'e gerek var mı? to support multiple federation executions

      #region Contracts
      // Preconditions
      Contract.Requires(fedexec != null, "CFederationExecution instance passed to FinalizeFederation() method is null.");
      Contract.Requires(fedexec.Name != null, "Federation Execution Name passed to InitializeFederation() method is null.");
      Contract.Requires(fedexec.FomModules.Count != 0, "FDD passed to InitializeFederation() method is null.");
      Contract.Requires(FederationExecution.FederateName != null, "Federate Name passed to InitializeFederation() method is null.");
      // Postconditions
      Contract.Ensures(FederationExecutionState == FederationExecutionStates.FEDEX_EXISTS, " at InitializeFederation().");
      Contract.Ensures(FederateState.HasFlag(FederateStates.JOINED), " at InitializeFederation().");
      #endregion

      bool res = Connect(CallbackModel.EVOKED, fedexec.ConnectionSettings);

      if (res)
        if (fedexec.FomModules.Count == 1)
          res = CreateFederationExecution(fedexec.Name, fedexec.FomModules[0]);
        else
          res = CreateFederationExecution(fedexec.Name, fedexec.FomModules);

      //Contract.Assert(FederationExecutionState == FederationExecutionStates.FEDEX_EXISTS, "After createFederation() call, federation state is not set to CREATED in InitializeFederation() method.");// Runs only in debug mode
      if (res)
        res = JoinFederationExecution(fedexec.FederateName, fedexec.FederateType, fedexec.Name, fedexec.FomModules);
      if (res)
      {
        // Get Dimension Handles
        GetAllDimensionHandles();
        // Data Distribution Management
        createRegions();
        // Declare publish and subscribe capabilities and interests.
        DeclareCapability();
      }

      return res;
    }

    /// <summary>
    /// Finalizes federation execution with user selected Resign Action:
    /// (1) Resign federation execution
    /// (2) Try to destroy federation execution
    /// (3) Disconnect
    /// </summary>
    /// <param name="fedexec">Federation Execution</param>
    /// <param name="action">Resign Action. Default is ResignAction.DELETE_OBJECTS_THEN_DIVEST</param>
    /// <returns>True if method call is succesfull.</returns>
    /// <remarks>Higher level interface. This method resigns federation, destroys federation if it is last one.
    /// </remarks>
    virtual public bool FinalizeFederation(CFederationExecution fedexec, ResignAction action = ResignAction.DELETE_OBJECTS_THEN_DIVEST)
    {
      #region Contracts
      // Preconditions
      Contract.Requires(fedexec != null, "CFederationExecution instance passed to FinalizeFederation() method is null.");
      Contract.Requires(fedexec.Name != null, "Federation Execution Name passed to FinalizeFederation() method is null.");
      #endregion

      bool res = ResignFederationExecution(action);
      if (res)
        DestroyFederationExecution(fedexec.Name);
      res = Disconnect();
      return res;

      // Log the Error into the eventlog (application)
      // !!! Needs admin rights
      //EventLog::WriteEntry("ExPFd","Exception Type: "+e->GetType()->FullName+"\r\nError Message: "+e->Message+"\r\nStack: "+e->StackTrace+""+Environment.NewLine,EventLogEntryType::Warning);
    }

    #endregion // High-Level Services

    #region RtiAmb Function Wrappers

    #region Federation Management

    /// <summary>
    /// IEEE1516.1-2010 4.2: Connects to RTI
    /// </summary>
    /// <param name="callbackModel"> Callback model </param>
    /// <param name="localSettingsDesignator">Connection paramaters in form of "protocol"://"ip":"port". For example: rti://127.0.0.1:12345 </param>
    /// <returns>returns True/False.</returns>    
    /// <remarks>This method is for IEEE1516-2010 compatiblity. Sets the federate status as CONNECTED.
    /// </remarks>
    virtual public bool Connect(CallbackModel callbackModel = CallbackModel.EVOKED, string localSettingsDesignator = "")
    {
      #region Contracts
      // Preconditions
      Contract.Requires(FederateState == FederateStates.NOTCONNECTED, " at Connect().");
      // Postconditions
      Contract.Ensures(FederateState.HasFlag(FederateStates.CONNECTED), "After Connect() call, federate state is not set correctly at Connect().");
      #endregion

      if (FederateState.HasFlag(FederateStates.NOTCONNECTED))
        _rtiAmb.connect(callbackModel, localSettingsDesignator);
      return FederateState.HasFlag(FederateStates.CONNECTED) ? true : false;
    }

    /// <summary>
    /// IEEE1516.1-2010 4.3: Disconnects from RTI
    /// </summary>
    /// <remarks>This method is for IEEE1516-2010 compatiblity. Sets the federate status as NOTCONNECTED.
    /// </remarks>
    virtual public bool Disconnect()
    {
      #region Contracts
      // Preconditions
      Contract.Requires(FederateState.HasFlag(FederateStates.CONNECTED | FederateStates.NOTJOINED), " at Disconnect().");
      // Postconditions
      Contract.Ensures(FederateState.HasFlag(FederateStates.NOTCONNECTED), "After Disconnect() call, federate state is not set correctly at Disconnect().");
      #endregion

      if (FederateState.HasFlag(FederateStates.CONNECTED))
        _rtiAmb.disconnect();
      return FederateState.HasFlag(FederateStates.NOTCONNECTED) ? true : false;
    }

    /// <summary>
    /// IEEE1516.1-2010 4.5: Creates a federation execution 
    /// </summary>
    /// <param name="fedexName">Name of the Federation Execution.</param>
    /// <param name="fomModule">Path of the FDD file.</param>
    /// <param name="logicalTimeImplementationName">Optional logical time implementation. If not provided, the RTI provided HLAfloat64Time representation of logical time shall be used.</param>
    /// <returns>True if method call is succesfull.</returns>
    /// <remarks>This method creates federation execution.
    /// </remarks>
    virtual public bool CreateFederationExecution(string fedexName, string fomModule, string logicalTimeImplementationName = "")
    {
      #region Contracts
      // Preconditions
      Contract.Requires(FederateState.HasFlag(FederateStates.CONNECTED), " at CreateFederationExecution().");
      Contract.Requires(FederationExecutionState.HasFlag(FederationExecutionStates.FEDEX_DOESNOTEXIST), " at CreateFederationExecution().");
      // Postconditions
      Contract.Ensures(FederationExecutionState.HasFlag(FederationExecutionStates.FEDEX_EXISTS), " at CreateFederationExecution().");
      #endregion

      if (FederationExecutionState.HasFlag(FederationExecutionStates.FEDEX_DOESNOTEXIST))
        _rtiAmb.createFederation(fedexName, fomModule, logicalTimeImplementationName);
      return FederationExecutionState.HasFlag(FederationExecutionStates.FEDEX_EXISTS) ? true : false;
    }

    /// <summary>
    /// IEEE1516.1-2010 4.5: Creates a federation execution with multiple FOM modules
    /// </summary>
    /// <param name="fedexName">Name of the Federation Execution.</param>
    /// <param name="fomModules">FOM modules</param>
    /// <param name="logicalTimeImplementationName">Optional logical time implementation. If not provided, the RTI provided HLAfloat64Time representation of logical time shall be used.</param>
    /// <returns></returns>
    virtual public bool CreateFederationExecution(string fedexName, List<string> fomModules, string logicalTimeImplementationName = "")
    {
      #region Contracts
      // Preconditions
      Contract.Requires(FederateState.HasFlag(FederateStates.CONNECTED), " at CreateFederationExecution().");
      Contract.Requires(FederationExecutionState.HasFlag(FederationExecutionStates.FEDEX_DOESNOTEXIST), " at CreateFederationExecution().");
      // Postconditions
      Contract.Ensures(FederationExecutionState.HasFlag(FederationExecutionStates.FEDEX_EXISTS), " at CreateFederationExecution().");
      #endregion

      if (FederationExecutionState.HasFlag(FederationExecutionStates.FEDEX_DOESNOTEXIST))
        _rtiAmb.createFederation(fedexName, fomModules, logicalTimeImplementationName);
      return FederationExecutionState.HasFlag(FederationExecutionStates.FEDEX_EXISTS) ? true : false;
    }

    /// <summary>
    /// IEEE1516.1-2010 4.5: Creates a federation execution with multiple FOM modules and a MIM module
    /// </summary>
    /// <param name="fedexName">Name of the Federation Execution.</param>
    /// <param name="fomModules">FOM modules</param>
    /// <param name="mimModule">Optional MIM designator. The RTI shall load the supplied MIM if specified; otherwise, it shall automatically load the standard MIM. the supplied MIM module designator shall not be “HLAstandardMIM.”</param>
    /// <param name="logicalTimeImplementationName">Optional logical time implementation. If not provided, the RTI provided HLAfloat64Time representation of logical time shall be used.</param>
    /// <returns></returns>
    virtual public bool CreateFederationExecutionWithMIM(string fedexName, List<string> fomModules, string mimModule = "", string logicalTimeImplementationName = "")
    {
      #region Contracts
      // Preconditions
      Contract.Requires(FederateState.HasFlag(FederateStates.CONNECTED), " at CreateFederationExecution().");
      Contract.Requires(FederationExecutionState.HasFlag(FederationExecutionStates.FEDEX_DOESNOTEXIST), " at CreateFederationExecution().");
      // Postconditions
      Contract.Ensures(FederationExecutionState.HasFlag(FederationExecutionStates.FEDEX_EXISTS), " at CreateFederationExecution().");
      #endregion

      if (FederationExecutionState.HasFlag(FederationExecutionStates.FEDEX_DOESNOTEXIST))
        _rtiAmb.createFederation(fedexName, fomModules, mimModule, logicalTimeImplementationName);
      return FederationExecutionState.HasFlag(FederationExecutionStates.FEDEX_EXISTS) ? true : false;
    }

    /// <summary>
    /// IEEE1516.1-2010 4.7: Requests a list of current federation executions
    /// </summary>
    virtual public void ListFederationExecutions()
    {
      if (FederateState.HasFlag(FederateStates.CONNECTED))
        _rtiAmb.listFederationExecutions();
    }

    /// <summary>
    /// IEEE1516.1-2010 4.9: Joins a federation execution 
    /// </summary>
    /// <param name="federateType">Type of the joined federate. The federate type is used to distinguish federate categories in federation save-and-restore operation. </param>
    /// <param name="federationExecutionName">Name of the Federation Execution to be joined.</param>
    /// <param name="fomModules">The FOM module designators are optional and are used to provide additional FDD. The contents cannot conflict with the current FDD specified in federa-tion execution creation.</param>
    /// <returns>True if method call is succesfull.</returns>
    /// <remarks>Federate joins a federation execution.
    /// </remarks>
    virtual public bool JoinFederationExecution(string federateType, string federationExecutionName, List<string> fomModules = null)
    {
      #region Contracts
      // Preconditions
      Contract.Requires(FederateState.HasFlag(FederateStates.CONNECTED), " at JoinFederationExecution().");
      Contract.Requires(FederationExecutionState.HasFlag(FederationExecutionStates.FEDEX_EXISTS), " at JoinFederationExecution().");
      Contract.Requires(FederateState.HasFlag(FederateStates.NOTJOINED), " at JoinFederationExecution().");
      // Postconditions
      Contract.Ensures(FederateState.HasFlag(FederateStates.JOINED), " at JoinFederationExecution().");
      #endregion

      FederateHandle = _rtiAmb.joinFederationExecution(federateType, federationExecutionName, fomModules);
      return FederateState.HasFlag(FederateStates.JOINED) ? true : false;
    }

    /// <summary>
    /// IEEE1516.1-2010 4.9: join federation execution with a federate name
    /// </summary>
    /// <param name="federateName">Name must be unique in the federation execution.</param>
    /// <param name="federateType">Type of the joined federate. The federate type is used to distinguish federate categories in federation save-and-restore operation. </param>
    /// <param name="federationExecutionName">Name of the Federation Execution to be joined.</param>
    /// <param name="fomModules">The FOM module designators are optional and are used to provide additional FDD. The contents cannot conflict with the current FDD specified in federa-tion execution creation.</param>
    /// <returns></returns>
    virtual public bool JoinFederationExecution(string federateName, string federateType, string federationExecutionName, List<string> fomModules = null)
    {
      #region Contracts
      // Preconditions
      Contract.Requires(FederateState.HasFlag(FederateStates.CONNECTED), " at JoinFederationExecution().");
      Contract.Requires(FederationExecutionState.HasFlag(FederationExecutionStates.FEDEX_EXISTS), " at JoinFederationExecution().");
      Contract.Requires(FederateState.HasFlag(FederateStates.NOTJOINED), " at JoinFederationExecution().");
      // Postconditions
      Contract.Ensures(FederateState.HasFlag(FederateStates.JOINED), " at JoinFederationExecution().");
      #endregion

      FederateHandle = _rtiAmb.joinFederationExecution(federateName, federateType, federationExecutionName, fomModules);
      return FederateState.HasFlag(FederateStates.JOINED) ? true : false;
    }
    /// <summary>
    /// HLA13 - join federation
    /// </summary>
    /// <param name="federateName">Name must be unique in the federation execution.</param>
    /// <param name="federationExecutionName">Name of the Federation Execution to be joined.</param>
    /// <returns></returns>
    virtual public bool JoinFederationExecution(string federateName, string federationExecutionName)
    {
      #region Contracts
      // Preconditions
      Contract.Requires(FederateState.HasFlag(FederateStates.CONNECTED), " at JoinFederationExecution().");
      Contract.Requires(FederationExecutionState.HasFlag(FederationExecutionStates.FEDEX_EXISTS), " at JoinFederationExecution().");
      Contract.Requires(FederateState.HasFlag(FederateStates.NOTJOINED), " at JoinFederationExecution().");
      // Postconditions
      Contract.Ensures(FederateState.HasFlag(FederateStates.JOINED), " at JoinFederationExecution().");
      #endregion

      FederateHandle = _rtiAmb.joinFederationExecution(federateName, federationExecutionName);
      return FederateState.HasFlag(FederateStates.JOINED) ? true : false;
    }


    /// <summary>
    /// Resigns federation execution with user selected Resign Action 
    /// </summary>
    /// <param name="action">Resign Action</param>
    /// <returns>True if method call is succesfull.</returns>
    /// <remarks>This method resigns federation execution.
    /// </remarks>
    virtual public bool ResignFederationExecution(ResignAction action = ResignAction.NO_ACTION)
    {
      #region Contracts
      // Preconditions
      Contract.Requires(FederateState.HasFlag(FederateStates.JOINED), " at ResignFederationExecution().");
      // Postconditions
      Contract.Ensures(FederateState.HasFlag(FederateStates.NOTJOINED), " at FinalizeFederation().");
      #endregion

      if (FederateState.HasFlag(FederateStates.JOINED))
        _rtiAmb.resignFederation((int)action);
      return FederateState.HasFlag(FederateStates.NOTJOINED) ? true : false;
    }

    /// <summary>
    /// Destroys the federation execution specified with a name
    /// </summary>
    /// <param name="fedexName">Name of the Federation Execution to be destroyed.</param>
    /// <returns>True if method call is succesfull.</returns>
    /// <remarks>This method destroys federation execution.
    /// </remarks>
    virtual public bool DestroyFederationExecution(string fedexName)
    {
      #region Contracts
      // Preconditions
      Contract.Requires(FederateState.HasFlag(FederateStates.CONNECTED), " at DestroyFederationExecution().");
      Contract.Requires(FederationExecutionState.HasFlag(FederationExecutionStates.FEDEX_EXISTS), " at DestroyFederationExecution().");
      // Postconditions
      Contract.Ensures(FederationExecutionState.HasFlag(FederationExecutionStates.FEDEX_DOESNOTEXIST), " at DestroyFederationExecution().");
      #endregion

      if (FederationExecutionState.HasFlag(FederationExecutionStates.FEDEX_EXISTS))
        _rtiAmb.destroyFederation(fedexName);
      return FederationExecutionState.HasFlag(FederationExecutionStates.FEDEX_DOESNOTEXIST) ? true : false;
    }

    /// <summary>
    /// This method shall be used to initiate the registration of an upcoming federation synchronization point label.
    /// </summary>
    /// <param name="label">Synchronization point label</param>
    /// <param name="tag">User-supplied tag</param>
    virtual public void RegisterFederationSynchronizationPoint(string label, string tag = "")
    {
      _rtiAmb.registerFederationSynchronizationPoint(label, tag);
    }

    /// <summary>
    /// This method shall be used to initiate the registration of an upcoming federation synchronization point label.
    /// </summary>
    /// <param name="label">Synchronization point label</param>
    /// <param name="tag">User-supplied tag</param>
    /// <param name="federates">set of joined federate designators</param>
    virtual public void RegisterFederationSynchronizationPoint(string label, string tag, List<uint> federates)
    {
      _rtiAmb.registerFederationSynchronizationPoint(label, tag, federates);
    }

    /// <summary>
    /// This method shall inform the RTI that the joined federate has reached the specified synchronization point.
    /// </summary>
    /// <param name="label">Synchronization point label</param>
    /// <param name="result">Optional synchronization-success indicator</param>
    virtual public void SynchronizationPointAchieved(string label, bool result = true)
    {
      _rtiAmb.synchronizationPointAchieved(label, result);
    }

    /// <summary>
    /// This method requests a federation save as soon as possible supplied with a string associated to a particular save.
    /// </summary>
    /// <param name="label">String label</param>
    /// <returns>True if method call is succesfull.</returns>
    virtual public void RequestFederationSave(string label)
    {
      _rtiAmb.requestFederationSave(label);
    }

    /// <summary>
    /// This method requests a federation save at the specified time supplied with a string associated to a particular save.
    /// </summary>
    /// <param name="label">String label</param>
    /// <param name="time">time</param>
    /// <returns>True if method call is succesfull.</returns>
    virtual public void RequestFederationSave(string label, double time)
    {
      _rtiAmb.requestFederationSave(label, time);
    }

    /// <summary>
    /// This method informs RTI that save begun.
    /// </summary>
    /// <returns>True if method call is succesfull.</returns>
    virtual public void FederateSaveBegun()
    {
      _rtiAmb.federateSaveBegun();
    }

    /// <summary>
    /// A false value indicates the unsuccessful completion of a save of a federate-managed state, as initiated by an initiateFederateSave() callback. A true value indicates a successful completion.
    /// </summary>
    /// <param name="isCompleted">isCompleted</param>
    /// <returns>True if method call is succesfull.</returns>
    virtual public void FederateSaveComplete(bool isCompleted)
    {
      // can we make this a property?
      _rtiAmb.federateSaveComplete(isCompleted);
    }

    /// <summary>
    /// IEEE1516.1-2010 4.21: abortFederationSave
    /// </summary>
    public virtual void AbortFederationSave()
    {
      _rtiAmb.abortFederationSave();
    }

    /// <summary>
    /// IEEE1516.1-2010 4.22: queryFederationSaveStatus
    /// </summary>
    public virtual void QueryFederationSaveStatus()
    {
      _rtiAmb.queryFederationSaveStatus();
    }

    /// <summary>
    /// This method requests a federation restore associated with a previously saved name federation state.
    /// </summary>
    /// <returns>True if method call is succesfull.</returns>
    virtual public void RequestFederationRestore(string label)
    {
      _rtiAmb.requestFederationRestore(label);
    }

    /// <summary>
    /// A false value indicates the unsuccessful completion of a restoration of a federate-managed state. A true value indicates a successful completion.
    /// </summary>
    /// <param name="isCompleted">isCompleted</param>
    /// <returns>True if method call is succesfull.</returns>
    virtual public void FederateRestoreComplete(bool isCompleted)
    {
      // can we make this a property?
      _rtiAmb.federateRestoreComplete(isCompleted);
    }

    /// <summary>
    /// IEEE1516.1-2010 4.30: abortFederationRestore
    /// </summary>
    public virtual void AbortFederationRestore()
    {
      _rtiAmb.abortFederationRestore();
    }
    /// <summary>
    /// IEEE1516.1-2010 4.31: queryFederationRestoreStatus
    /// </summary>
    public virtual void QueryFederationRestoreStatus()
    {
      _rtiAmb.queryFederationRestoreStatus();
    }

    #endregion // Federation Management

    #region Declaration Management
    /// <summary>
    /// Declares capability of a federate in terms of Publish/Subscribe:
    /// (1) Enables object class relevance advisory switch.
    /// (2) Gets object class and attribute handles.
    /// (3) Publishes/subscribes all the object classes in SOM according to their PS status.
    /// (4) Enables interaction relevance advisory switch.
    /// (5) Gets interaction class and parameter handles.
    /// (6) Publishes/subscribes all the interaction classes in SOM according to their PS status.
    /// </summary>
    /// <returns>True if method call is succesfull.</returns>
    virtual public bool DeclareCapability()
    {
      try
      {
        // Enable advisory switches
        EnableObjectClassRelevanceAdvisorySwitch();
        EnableInteractionRelevanceAdvisorySwitch();
        EnableAttributeRelevanceAdvisorySwitch();

        // Publish and Subscribe the OC using Federate's OC List
        foreach (var oc in _som.OCList)
        {
          // Get Class Handle
          _rtiAmb.getClassHandleFromRti(oc);
          // Get All Attribute Handles
          _rtiAmb.getAttributeHandlesFromRti(oc);
          // Publish and/or Subscribe
          switch (oc.ClassPS)
          {
            case PSKind.Publish:
              PublishObjectClass(oc);
              break;
            case PSKind.Subscribe:
              SubscribeObjectClass(oc);
              break;
            case PSKind.PublishSubscribe:
              PublishObjectClass(oc);
              SubscribeObjectClass(oc);
              break;
          };
        }
        // Publish and Subscribe the IC using Federate's IC List
        foreach (var ic in _som.ICList)
        {
          // Get Class Handle
          _rtiAmb.getClassHandleFromRti(ic);
          // Get All Attribute Handles
          _rtiAmb.getParameterHandlesFromRti(ic);
          // Publish and/or Subscribe
          switch (ic.ClassPS)
          {
            case PSKind.Publish:
              _rtiAmb.publishInteractionClass(ic);
              break;
            case PSKind.Subscribe:
              _rtiAmb.subscribeInteractionClass(ic);
              break;
            case PSKind.PublishSubscribe:
              _rtiAmb.publishInteractionClass(ic);
              _rtiAmb.subscribeInteractionClass(ic);
              break;
          };
        }
        return true;
      }
      catch (Exception)
      {
        return false;
      }
    }

    /// <summary>
    /// Publish OC - With its all subscribable attributes 
    /// </summary>
    /// <param name="oc">Object class</param>
    /// <returns>True if method call is succesfull.</returns>
    virtual public bool PublishObjectClass(HlaObjectClass oc)
    {
      return PublishObjectClass(oc, oc.Attributes);
    }

    /// <summary>
    /// Publish OC - With some selected attributes 
    /// </summary>
    /// <param name="oc">Object class</param>
    /// <param name="attributes">Attributes</param>
    /// <returns>True if method call is succesfull.</returns>
    virtual public bool PublishObjectClass(HlaObjectClass oc, List<HlaAttribute> attributes)
    {
      _rtiAmb.publishObjectClass(oc, attributes);
      return true;
    }

    /// <summary>
    /// Subscribes OC - With its all subscribable attributes 
    /// </summary>
    /// <param name="oc">Object class</param>
    /// <returns>True if method call is succesfull.</returns>
    virtual public bool SubscribeObjectClass(HlaObjectClass oc)
    {
      return SubscribeObjectClass(oc, oc.Attributes);
    }

    /// <summary>
    /// Subscribe OC - With some selected attributes 
    /// </summary>
    /// <param name="oc">Object class</param>
    /// <param name="attributes">Attributes</param>
    /// <param name="active">default is true</param>
    /// <returns>True if method call is succesfull.</returns>
    virtual public bool SubscribeObjectClass(HlaObjectClass oc, List<HlaAttribute> attributes, bool active = true)
    {
      return _rtiAmb.subscribeObjectClass(oc, attributes, active);
    }

    /// <summary>
    /// UnsubscribeInteractionClass 
    /// </summary>
    /// <returns>True if method call is succesfull.</returns>
    virtual public bool UnsubscribeInteractionClass(HlaInteractionClass ic)
    {
      return _rtiAmb.unsubscribeInteractionClass(ic);
    }

    /// <summary>
    /// UnsubscribeObjectClass - For all attributes of an object class
    /// </summary>
    /// <returns>True if method call is succesfull.</returns>
    virtual public bool UnsubscribeObjectClass(HlaObjectClass oc)
    {
      return _rtiAmb.unsubscribeObjectClass(oc);
    }

    #endregion // Declaration Management

    #region Data Distribution Management

    /// <summary>
    /// Racon: createRegions for HLA13
    /// </summary>
    /// <returns>True if method call is succesfull.</returns>
    virtual internal bool createRegions()
    {
      try
      {
        foreach (var space in _som.RSList)
        {
          space.RtiAmb = _rtiAmb;
          // Set Dimensions
          foreach (var dimension in space.Dimensions)
          {
            dimension.Space = space;
            dimension.RtiAmb = _rtiAmb;
          }
          // Create Regions
          foreach (var region in space.Regions)
          {
            region.RtiAmb = _rtiAmb;
            region.CreateRegion(space);
          }
        }
        return true;
      }
      catch (Exception e)
      {
        string msg = "EXC-(RACoN.Federation.GenericFederate.createRegions):" + e.ToString();
        logger.Add(msg, LogLevel.WARN);
        return false;
      }
    }

    /// <summary>
    /// IEEE1516.1-2010 9.2: createRegion
    /// </summary>
    /// <param name="region"></param>
    /// <param name="dimensions"></param>
    /// <returns></returns>
    public virtual uint CreateRegion(HlaRegion region, List<HlaDimension> dimensions)
    {
      return _rtiAmb.createRegion(region, dimensions);
    }

    /// <summary>
    /// IEEE1516.1-2010 9.3: commitRegionModifications
    /// </summary>
    /// <param name="regions"></param>
    public virtual void CommitRegionModifications(List<HlaRegion> regions)
    {
      _rtiAmb.commitRegionModifications(regions);
    }

    /// <summary>
    /// IEEE1516.1-2010 9.4: deleteRegion
    /// </summary>
    /// <param name="region"></param>
    public virtual void DeleteRegion(HlaRegion region)
    {
      _rtiAmb.deleteRegion(region);
    }

    /// <summary>
    /// IEEE1516.1-2010 9.5: registerObjectInstanceWithRegions
    /// </summary>
    /// <param name="objectTobeRegistered"></param>
    /// <param name="pairs">AttributeHandleSetRegionHandleSetPairVector</param>
    public virtual bool RegisterHlaObject(HlaObject objectTobeRegistered, AttributeHandleSetRegionHandleSetPairVector pairs)
    {
      _rtiAmb.registerObjectInstanceWithRegions(objectTobeRegistered, pairs);
      return true;
    }
    /// <summary>
    /// Registers object with a specific region with all its publishable (P) attributes. Here, we assume that all attributes are related with a single region.
    /// </summary>
    /// <param name="theObject">Object to be registered. If object name is set then this method registers the object with its name. Object name must be unique.</param>
    /// <param name="region">The region. Here, we assume that all attributes are related with this region.</param>
    /// <returns>Returns true/false.</returns>
    virtual public bool RegisterHlaObject(HlaObject theObject, HlaRegion region)
    {
      #region Contracts
      // Preconditions
      //a) The federate is connected to the RTI.// For IEEE1516.1_2010
      //b) The federation execution exists.
      Contract.Requires(FederationExecutionState == FederationExecutionStates.FEDEX_EXISTS, " at RegisterHlaObject().");
      //c) The federate is joined to that federation execution.
      Contract.Requires(FederateState.HasFlag(FederateStates.JOINED), " at RegisterHlaObject().");
      //d) The object class is defined in the FDD
      Contract.Requires(theObject.Type.Handle != 0, " at RegisterHlaObject()."); // Class handle will be 0 if not P/S.
      //e) The joined federate is publishing the object class.
      Contract.Requires(theObject.Type.ClassPS == PSKind.PublishSubscribe || theObject.Type.ClassPS == PSKind.Publish, " at RegisterHlaObject().");
      //f) If the optional object instance name argument is supplied, that name is reserved and not already coadunated with another object instance.
      //g) Federate save not in progress.
      //h) Federate restore not in progress.

      // Postconditions
      //a) The returned object instance handle is coadunated with the object instance.
      Contract.Ensures(theObject.Handle != 0, " at RegisterHlaObject().");
      //b) The joined federate acquires ownership of the instance attributes that correspond to the currently published class attributes for the specified object class.
      //c) If the optional object instance name argument is supplied, that name is coadunated with the object instance.     
      #endregion

      //HlaObjectClass oc = _som.OCList.SingleOrDefault(p => p.Handle == theObject.Type.Handle); // returns null if not found
      bool res = false;
      //if (oc != null)
      res = RegisterHlaObject(theObject, theObject.Type.Attributes.ToList(), region);
      return res;
    }

    /// <summary>
    /// Registers object with a specific region with some of its publishable attributes. Here, we assume that all attributes are related with a single region.
    /// </summary>
    /// <param name="theObject">Object to be registered.</param>
    /// <param name="attributes">Selected object attributes that will be related with the region.</param>
    /// <param name="region">The region. Here, we assume that all attributes are related with this region.</param>
    /// <returns>Returns true/false.</returns>
    virtual public bool RegisterHlaObject(HlaObject theObject, List<HlaAttribute> attributes, HlaRegion region)
    {
      #region Contracts
      // Preconditions
      //a) The federate is connected to the RTI.
      // For IEEE1516.1_2010
      //b) The federation execution exists.
      Contract.Requires(FederationExecutionState == FederationExecutionStates.FEDEX_EXISTS, " at RegisterHlaObject().");
      //c) The federate is joined to that federation execution.
      Contract.Requires(FederateState.HasFlag(FederateStates.JOINED), " at RegisterHlaObject().");
      //d) The object class is defined in the FDD
      Contract.Requires(theObject.Type.Handle != 0, " at RegisterHlaObject()."); // Class handle will be 0 if not P/S.
      //e) The joined federate is publishing the object class.
      Contract.Requires(theObject.Type.ClassPS == PSKind.PublishSubscribe || theObject.Type.ClassPS == PSKind.Publish, " at RegisterHlaObject().");
      //f) If the optional object instance name argument is supplied, that name is reserved and not already coadunated with another object instance.
      //g) Federate save not in progress.
      //h) Federate restore not in progress.

      // Postconditions
      //a) The returned object instance handle is coadunated with the object instance.
      Contract.Ensures(theObject.Handle != 0, " at RegisterHlaObject().");
      //b) The joined federate acquires ownership of the instance attributes that correspond to the currently published class attributes for the specified object class.
      //c) If the optional object instance name argument is supplied, that name is coadunated with the object instance.     
      #endregion

      // Select only P or PS attributes
      List<HlaAttribute> pAttributes = new List<HlaAttribute>();
      List<HlaRegion> regions = new List<HlaRegion>();
      foreach (var attr in attributes)
      {
        if ((attr.AttributePS == PSKind.Publish) || (attr.AttributePS == PSKind.PublishSubscribe))
        {
          pAttributes.Add(attr);
          regions.Add(region);
        }
      }
      _rtiAmb.registerObjectInstanceWithRegions(theObject, pAttributes, regions);
      return true;
    }

    /// <summary>
    /// Registers object with its publishable attributes with specific regions. Each attribute may be associated with a different region. To do this, the user must pair an attribute with a region and then add the pair to a dictionary.
    /// </summary>
    /// <param name="theObject">Object to be registered.</param>
    /// <param name="attributeRegionPairs">Selected object attributes that will be related with the region.</param>
    /// <returns>Returns true/false.</returns>
    /// <example>
    /// This sample shows how to call the RegisterHlaObject(HlaObject theObject, AttributeRegionPairs attributeRegionPairs) method.
    /// <code>
    /// RACoN.ObjectModel.AttributeRegionPairs pairs = new RACoN.ObjectModel.AttributeRegionPairs();
    /// pairs.Add(myAttribute, myRegion);
    /// myFederate.RegisterHlaObject(myObject, pairs);
    /// </code>
    /// </example>
    virtual public bool RegisterHlaObject(HlaObject theObject, AttributeRegionPairs attributeRegionPairs)
    {
      #region Contracts
      // Preconditions
      //a) The federate is connected to the RTI.
      // For IEEE1516.1_2010
      //b) The federation execution exists.
      Contract.Requires(FederationExecutionState == FederationExecutionStates.FEDEX_EXISTS, " at RegisterHlaObject().");
      //c) The federate is joined to that federation execution.
      Contract.Requires(FederateState.HasFlag(FederateStates.JOINED), " at RegisterHlaObject().");
      //d) The object class is defined in the FDD
      Contract.Requires(theObject.Type.Handle != 0, " at RegisterHlaObject()."); // Class handle will be 0 if not P/S.
      //e) The joined federate is publishing the object class.
      Contract.Requires(theObject.Type.ClassPS == PSKind.PublishSubscribe || theObject.Type.ClassPS == PSKind.Publish, " at RegisterHlaObject().");
      //f) If the optional object instance name argument is supplied, that name is reserved and not already coadunated with another object instance.
      //g) Federate save not in progress.
      //h) Federate restore not in progress.

      // Postconditions
      //a) The returned object instance handle is coadunated with the object instance.
      Contract.Ensures(theObject.Handle != 0, " at RegisterHlaObject().");
      //b) The joined federate acquires ownership of the instance attributes that correspond to the currently published class attributes for the specified object class.
      //c) If the optional object instance name argument is supplied, that name is coadunated with the object instance.     
      #endregion

      // This is already ensured by Dictionary structure. Only unique keys are added to the dictionary
      //// Check that each attribute is listed only one time in the pairs.
      //var duplicates = attributeRegionPairs.GetPairs().Keys.GroupBy(x => x)
      //  .Where(x => x.Count() > 1).Select(x => x.Key).ToList();
      //if (duplicates.Count != 0) return false;

      // Select only P or PS attributes
      List<HlaAttribute> attributes = new List<HlaAttribute>();
      List<HlaRegion> regions = new List<HlaRegion>();
      foreach (var pair in attributeRegionPairs.GetPairs())
      {
        // Check that provided attribute is P or PS
        if ((pair.Key.AttributePS == PSKind.Publish) || (pair.Key.AttributePS == PSKind.PublishSubscribe))
        {
          // Get Attributes
          attributes.Add(pair.Key);
          // Get Regions
          regions.Add(pair.Value);
        }
      }
      _rtiAmb.registerObjectInstanceWithRegions(theObject, attributes, regions);
      return true;
    }

    /// <summary>
    /// IEEE1516.1-2010 9.6: associateRegionsForUpdates
    /// </summary>
    /// <param name="obj"></param>
    /// <param name="pairs"></param>
    public virtual bool associateRegionsForUpdates(HlaObject obj, AttributeHandleSetRegionHandleSetPairVector pairs)
    {
      return _rtiAmb.associateRegionsForUpdates(obj, pairs);
    }

    /// <summary>
    /// HLA13: AssociateRegionForUpdates
    /// </summary>
    /// <returns>True if method call is succesfull.</returns>
    virtual public bool AssociateRegionForUpdates(HlaRegion region, HlaObject hlaObject, List<HlaAttribute> attributes)
    {
      return _rtiAmb.associateRegionForUpdates(region, hlaObject, attributes);
    }

    /// <summary>
    /// IEEE1516.1-2010 9.7: unassociateRegionsForUpdates
    /// </summary>
    /// <param name="obj"></param>
    /// <param name="pairs"></param>
    public virtual bool UnassociateRegionsForUpdates(HlaObject obj, AttributeHandleSetRegionHandleSetPairVector pairs)
    {
      return _rtiAmb.unassociateRegionsForUpdates(obj, pairs);
    }

    /// <summary>
    /// HLA13: unassociateRegionForUpdates
    /// </summary>
    /// <returns>True if method call is succesfull.</returns>
    virtual public bool UnassociateRegionForUpdates(HlaRegion region, HlaObject hlaObject)
    {
      return _rtiAmb.unassociateRegionForUpdates(region, hlaObject);
    }

    /// <summary>
    /// IEEE1516.1-2010 9.8: subscribeObjectClassAttributesWithRegions
    /// </summary>
    /// <param name="oc"></param>
    /// <param name="pairs"></param>
    /// <param name="passiveSubscriptionIndicator"></param>
    public virtual bool subscribeObjectClassAttributesWithRegions(HlaObjectClass oc, AttributeHandleSetRegionHandleSetPairVector pairs, bool passiveSubscriptionIndicator = true)
    {
      return _rtiAmb.subscribeObjectClassAttributesWithRegions(oc, pairs, passiveSubscriptionIndicator);
    }

    /// <summary>
    /// // Subscribe Object Class With Region
    /// </summary>
    /// <returns>True if method call is succesfull.</returns>
    virtual public bool subscribeObjectClassAttributesWithRegion(HlaObjectClass oc, List<HlaAttribute> attributes, HlaRegion region, bool active = true)
    {
      return _rtiAmb.subscribeObjectClassAttributesWithRegions(oc, attributes, region, active);
    }

    /// <summary>
    /// IEEE1516.1-2010 9.9: unsubscribeObjectClassWithRegions
    /// </summary>
    /// <param name="oc"></param>
    /// <param name="pairs"></param>
    /// <returns></returns>
    public virtual bool UnsubscribeObjectClassWithRegions(HlaObjectClass oc, AttributeHandleSetRegionHandleSetPairVector pairs)
    {
      return _rtiAmb.unsubscribeObjectClassWithRegions(oc, pairs);
    }
    /// <summary>
    /// HLA13: Unsubscribe Object Class With Region
    /// </summary>
    /// <returns>True if method call is succesfull.</returns>
    virtual public bool UnsubscribeObjectClassWithRegions(HlaObjectClass oc, HlaRegion region)
    {
      return _rtiAmb.unsubscribeObjectClassWithRegions(oc, region);
    }

    /// <summary>
    /// IEEE1516.1-2010 9.10: subscribeInteractionClassWithRegions
    /// </summary>
    /// <param name="ic"></param>
    /// <param name="regions"></param>
    /// <param name="indicator"></param>
    /// <returns></returns>
    public virtual bool SubscribeInteractionClassWithRegions(HlaInteractionClass ic, List<HlaRegion> regions, bool indicator = true)
    {
      return _rtiAmb.subscribeInteractionClassWithRegions(ic, regions, indicator);
    }
    /// <summary>
    /// HLA13: Subscribe Interaction With Region
    /// </summary>
    /// <returns>True if method call is succesfull.</returns>
    virtual public bool SubscribeInteractionClass(HlaInteractionClass ic, HlaRegion region)
    {
      return _rtiAmb.subscribeInteractionClassWithRegion(ic, region);
    }

    /// <summary>
    /// IEEE1516.1-2010 9.11: unSubscribeInteractionClassWithRegions
    /// </summary>
    /// <param name="ic"></param>
    /// <param name="regions"></param>
    /// <returns></returns>
    public virtual bool UnSubscribeInteractionClassWithRegions(HlaInteractionClass ic, List<HlaRegion> regions)
    {
      return _rtiAmb.unSubscribeInteractionClassWithRegions(ic, regions);
    }
    /// <summary>
    /// HLA13: Unsubscribe Interaction Class With Region
    /// </summary>
    /// <returns>True if method call is succesfull.</returns>
    virtual public bool UnsubscribeInteractionClass(HlaInteractionClass ic, HlaRegion region)
    {
      return _rtiAmb.unSubscribeInteractionClassWithRegion(ic, region);
    }

    /// <summary>
    /// IEEE1516.1-2010 9.12: sendInteractionWithRegions
    /// </summary>
    /// <param name="ic"></param>
    /// <param name="regions"></param>
    /// <param name="user_supplied_tag"></param>
    /// <returns></returns>
    public virtual bool SendInteractionWithRegions<_Type>(HlaInteractionClass ic, List<HlaRegion> regions, _Type user_supplied_tag)
    {
      // Convert to variable length data
      VariableLengthDataWrapper tag = new VariableLengthDataWrapper();
      tag.AddData(user_supplied_tag);

      return _rtiAmb.sendInteractionWithRegions(ic, regions, tag);
    }
    /// <summary>
    /// IEEE1516.1-2010 9.12: sendInteractionWithRegions with timestamp
    /// </summary>
    /// <param name="ic"></param>
    /// <param name="regions"></param>
    /// <param name="user_supplied_tag"></param>
    /// <param name="timestamp"></param>
    /// <returns></returns>
    public virtual MessageRetraction SendInteractionWithRegions<_Type>(HlaInteractionClass ic, List<HlaRegion> regions, _Type user_supplied_tag, double timestamp)
    {
      // Convert to variable length data
      VariableLengthDataWrapper tag = new VariableLengthDataWrapper();
      tag.AddData(user_supplied_tag);

      return _rtiAmb.sendInteractionWithRegions(ic, regions, tag, timestamp);
    }

    /// <summary>
    /// IEEE1516.1-2010 9.13: requestClassAttributeValueUpdateWithRegions
    /// </summary>
    /// <param name="oc"></param>
    /// <param name="pairs"></param>
    /// <param name="user_supplied_tag"></param>
    /// <returns></returns>
    public virtual bool RequestAttributeValueUpdateWithRegions<_Type>(HlaObjectClass oc, AttributeHandleSetRegionHandleSetPairVector pairs, _Type user_supplied_tag)
    {
      // Convert to variable length data
      VariableLengthDataWrapper tag = new VariableLengthDataWrapper();
      tag.AddData(user_supplied_tag);

      return _rtiAmb.requestClassAttributeValueUpdateWithRegions(oc, pairs, tag);
    }
    /// <summary>
    /// HLA13: Request Class Attribute Value Update w/ Region
    /// </summary>
    /// <returns>True if method call is succesfull.</returns>
    virtual public bool RequestClassAttributeValueUpdateWithRegion(HlaObjectClass theClass, List<HlaAttribute> attributes, HlaRegion region)
    {
      return _rtiAmb.requestClassAttributeValueUpdateWithRegion(theClass, attributes, region);
    }

    #endregion

    #region Object Management
    /// <summary>
    /// IEEE1516.1-2010 6.10: UpdateAttributeValues
    /// </summary>
    /// <returns>True if method call is succesfull.</returns>
    virtual public bool UpdateAttributeValues<_Type>(HlaObject theObject, _Type user_supplied_tag)
    {
      #region Contracts
      // Preconditions
      //a) The federate is connected to the RTI.
      //b) The federation execution exists.
      Contract.Requires(FederationExecutionState == FederationExecutionStates.FEDEX_EXISTS, " at UpdateAttributeValues().");
      //c) The federate is joined to that federation execution.
      Contract.Requires(FederateState.HasFlag(FederateStates.JOINED), " at UpdateAttributeValues().");
      //d) The joined federate owns the instance attributes for which values are provided.
      Contract.Requires(theObject.Handle != 0, " at UpdateAttributeValues().");
      //e) The attributes are defined in the FDD.
      //Contract.Requires(theObject.Type.Attributes.Count != 0, " at UpdateAttributeValues().");
      //f) An object instance with the specified designator exists.
      //g) The joined federate knows about the object instance with the specified designator.
      //h) The timestamp value shall be in accordance with the constraints stated in Clause 8 (if optional timestamp argument is supplied).
      //i) If the optional timestamp argument is supplied to this service invocation, the invoking joined federate is time-regulating, and it has invoked the Delete Object Instance service for the specified object instance with a timestamp argument (while time-regulating), then the update’s timestamp shall be less than or equal to the delete’s timestamp.
      //j) Federate save not in progress.
      //k) Federate restore not in progress.

      // Postconditions
      // a) The new instance attribute values have been supplied to the RTI.
      #endregion

      // Convert to variable length data
      VariableLengthDataWrapper tag = new VariableLengthDataWrapper();
      tag.AddData(user_supplied_tag);

      return _rtiAmb.updateAttributeValues(theObject, tag);
    }
    /// <summary>
    /// IEEE1516.1-2010 6.10: UpdateAttributeValues with timestamp
    /// </summary>
    virtual public MessageRetraction UpdateAttributeValues<_Type>(HlaObject theObject, _Type user_supplied_tag, double timestamp)
    {
      #region Contracts
      // Preconditions
      //a) The federate is connected to the RTI.
      //b) The federation execution exists.
      Contract.Requires(FederationExecutionState == FederationExecutionStates.FEDEX_EXISTS, " at UpdateAttributeValues().");
      //c) The federate is joined to that federation execution.
      Contract.Requires(FederateState.HasFlag(FederateStates.JOINED), " at UpdateAttributeValues().");
      //d) The joined federate owns the instance attributes for which values are provided.
      Contract.Requires(theObject.Handle != 0, " at UpdateAttributeValues().");
      //e) The attributes are defined in the FDD.
      //Contract.Requires(theObject.Type.Attributes.Count != 0, " at UpdateAttributeValues().");
      //f) An object instance with the specified designator exists.
      //g) The joined federate knows about the object instance with the specified designator.
      //h) The timestamp value shall be in accordance with the constraints stated in Clause 8 (if optional timestamp argument is supplied).
      //i) If the optional timestamp argument is supplied to this service invocation, the invoking joined federate is time-regulating, and it has invoked the Delete Object Instance service for the specified object instance with a timestamp argument (while time-regulating), then the update’s timestamp shall be less than or equal to the delete’s timestamp.
      //j) Federate save not in progress.
      //k) Federate restore not in progress.

      // Postconditions
      // a) The new instance attribute values have been supplied to the RTI.
      #endregion

      // Convert to variable length data
      VariableLengthDataWrapper tag = new VariableLengthDataWrapper();
      tag.AddData(user_supplied_tag);

      return _rtiAmb.updateAttributeValues(theObject, tag, timestamp);
    }
    /// <summary>
    /// HLA13: UpdateAttributeValues
    /// </summary>
    /// <param name="theObject"></param>
    /// <returns></returns>
    virtual public bool UpdateAttributeValues(HlaObject theObject)
    {
      if (_rtiAmb.updateAttributeValues(theObject)) return true;
      else return false;
    }
    /// <summary>
    /// HLA13: UpdateAttributeValues
    /// </summary>
    /// <param name="theObject"></param>
    /// <param name="timestamp"></param>
    /// <returns></returns>
    virtual public MessageRetraction UpdateAttributeValues(HlaObject theObject, double timestamp)
    {
      return _rtiAmb.updateAttributeValues(theObject, timestamp);
    }

    /// <summary>
    /// IEEE1516.1-2010 6.12: Sends an interaction. If a region is specified then send the interaction in that region.
    /// </summary>
    /// <param name="theInteraction">HLA interaction to be sent.</param>
    /// <param name="user_supplied_tag"></param>
    /// <returns>True if method call is succesfull.</returns>
    virtual public bool SendInteraction<_Type>(HlaInteraction theInteraction, _Type user_supplied_tag)
    {
      // Convert to variable length data
      VariableLengthDataWrapper tag = new VariableLengthDataWrapper();
      tag.AddData(user_supplied_tag);

      return _rtiAmb.sendInteraction(theInteraction, tag);
    }
    /// <summary>
    /// IEEE1516.1-2010 6.12: Send Interaction with timestamp.
    /// </summary>
    /// <param name="theInteraction">HLA interaction to be sent.</param>
    /// <param name="user_supplied_tag"></param>
    /// <param name="timestamp">timestamp.</param>
    /// <returns> returns Event Retraction Handle.</returns>
    virtual public MessageRetraction SendInteraction<_Type>(HlaInteraction theInteraction, _Type user_supplied_tag, double timestamp)
    {
      // Convert to variable length data
      VariableLengthDataWrapper tag = new VariableLengthDataWrapper();
      tag.AddData(user_supplied_tag);

      return _rtiAmb.sendInteraction(theInteraction, tag, timestamp);
    }
    /// <summary>
    /// HLA13: SendInteraction
    /// </summary>
    /// <param name="theInteraction"></param>
    /// <param name="timestamp"></param>
    /// <returns></returns>
    virtual public MessageRetraction SendInteraction(HlaInteraction theInteraction, double timestamp)
    {
      return _rtiAmb.sendInteraction(theInteraction, timestamp);
    }
    /// <summary>
    /// HLA13: SendInteraction
    /// </summary>
    /// <param name="theInteraction"></param>
    /// <param name="region"></param>
    /// <returns></returns>
    virtual public bool SendInteraction(HlaInteraction theInteraction, HlaRegion region = null)
    {
      bool res = false;

      if (region == null)
        res = _rtiAmb.sendInteraction(theInteraction);
      else
        res = _rtiAmb.sendInteractionWithRegion(theInteraction, region);

      return res;
    }

    /// <summary>
    /// IEEE1516.1-2010 6.14: Delete Object Instance. With user-supplied tag.
    /// </summary>
    /// <param name="obj">HLA Object</param>
    /// <param name="user_supplied_tag">User-Supplied Tag</param>
    /// <returns>true/false</returns>
    virtual public bool DeleteObjectInstance<_Type>(HlaObject obj, _Type user_supplied_tag)
    {
      // Convert to IntPtr
      VariableLengthDataWrapper tag = new VariableLengthDataWrapper();
      tag.AddData(user_supplied_tag);

      if (_rtiAmb.deleteObjectInstance(obj, tag)) return true;
      else return false;
    }
    /// <summary>
    /// IEEE1516.1-2010 6.14: Schedule to delete Object Instance at a specified time. user-supplied tag.
    /// </summary>
    /// <param name="obj">HLA Object</param>
    /// <param name="user_supplied_tag">User-Supplied Tag</param>
    /// <param name="timestamp">Timestamp</param>
    /// <returns>true/false</returns>
    virtual public MessageRetraction DeleteObjectInstance<_Type>(HlaObject obj, _Type user_supplied_tag, double timestamp)
    {
      // Convert to IntPtr
      VariableLengthDataWrapper tag = new VariableLengthDataWrapper();
      tag.AddData(user_supplied_tag);

      return (_rtiAmb.deleteObjectInstance(obj, tag, timestamp));
    }
    /// <summary>
    /// HLA13: Delete Object Instance. Null user-supplied tag.
    /// </summary>
    virtual public bool DeleteObjectInstance(HlaObject obj)
    {
      if (_rtiAmb.deleteObjectInstance(obj, obj.Tag)) return true;
      else return false;
    }
    /// <summary>
    /// HLA13: Delete Object Instance. Null user-supplied tag.
    /// </summary>
    virtual public MessageRetraction DeleteObjectInstance(HlaObject obj, double timestamp)
    {
      return (_rtiAmb.deleteObjectInstance(obj, timestamp, obj.Tag));
    }

    /// <summary>
    /// Request Attribute Value Update
    /// </summary>
    /// <param name="theClass">HLA Object Class</param>
    /// <param name="user_supplied_tag">user_supplied_tag</param>
    /// <returns>True if method call is succesfull.</returns>
    /// <remarks>This method is called to request an update of the values of all attributes for all objects related to the specified HLA object class in the parameter.
    /// </remarks>
    virtual public bool RequestAttributeValueUpdate<_Type>(HlaObjectClass theClass, _Type user_supplied_tag)
    {
      //List<HlaAttribute> attributes = new List<HlaAttribute>();
      //foreach (var attribute in theClass.Attributes)
      //{
      //  attributes.Add(attribute);
      //}

      // Convert to IntPtr
      VariableLengthDataWrapper tag = new VariableLengthDataWrapper();
      tag.AddData(user_supplied_tag);

      return RequestAttributeValueUpdate(theClass, theClass.Attributes.ToList(), tag);
    }
    /// <summary>
    /// Request Attribute Value Update
    /// </summary>
    /// <param name="theClass">HLA Object Class</param>
    /// <param name="attributes">The attribute set that update requested.</param>
    /// <param name="user_supplied_tag">user_supplied_tag</param>
    /// <returns>True if method call is succesfull.</returns>
    /// <remarks>This method is called to request an update of the values of the selected attributes for all objects related to the specified HLA object class in the parameter.
    /// </remarks>
    /// <example>
    /// This sample shows how to call the requestClassAttributeValueUpdate() method with some selected attributes.
    /// <code>
    /// List&lt;HlaAttribute&gt; attributes = new List&lt;HlaAttribute&gt;();
    /// attributes.Add(Som.UserOC.NickName);
    /// attributes.Add(Som.UserOC.Status);
    /// RequestAttributeValueUpdate(Som.UserOC, attributes);
    /// </code>
    /// </example>
    virtual public bool RequestAttributeValueUpdate<_Type>(HlaObjectClass theClass, List<HlaAttribute> attributes, _Type user_supplied_tag)
    {
      // Convert to IntPtr
      VariableLengthDataWrapper tag = new VariableLengthDataWrapper();
      tag.AddData(user_supplied_tag);

      return _rtiAmb.requestAttributeValueUpdate(theClass, attributes, tag);
    }
    /// <summary>
    /// Request Attribute Value Update
    /// </summary>
    /// <param name="theObject">HLA Object</param>
    /// <param name="user_supplied_tag">user_supplied_tag</param>
    /// <returns>True if method call is succesfull.</returns>
    /// <remarks>This method requests an update of the values of all attributes for a specific HLA object specified in the parameter.
    /// </remarks>
    virtual public bool RequestAttributeValueUpdate<_Type>(HlaObject theObject, _Type user_supplied_tag)
    {
      // Convert to IntPtr
      VariableLengthDataWrapper tag = new VariableLengthDataWrapper();
      tag.AddData(user_supplied_tag);

      //HlaObjectClass oc = _som.OCList.SingleOrDefault(p => p.Handle == theObject.ClassHandle); // returns null if not found
      bool res = false;
      try
      {
        res = _rtiAmb.requestAttributeValueUpdate(theObject, theObject.Type.Attributes.ToList(), tag);// if user forgets to set type of the object, then an exception is generated
      }
      catch (Exception e)
      {
        logger.Add("When requesting attribute value, the object type for (" + theObject.Name + ") is not set. " + e.Message, LogLevel.WARN);
      }
      return res;
    }
    /// <summary>
    /// Request Attribute Value Update
    /// </summary>
    /// <param name="theObject">HLA Object</param>
    /// <param name="attributes">The attribute set that update requested.</param>
    /// <param name="user_supplied_tag">user_supplied_tag</param>
    /// <returns>True if method call is succesfull.</returns>
    /// <remarks>This method requests an update of the values of the selected attributes for a specific HLA object specified in the parameter.
    /// </remarks>
    /// <example>
    /// This sample shows how to call the requestClassAttributeValueUpdate() method with some selected attributes.
    /// <code>
    /// List&lt;HlaAttribute&gt; attributes = new List&lt;HlaAttribute&gt;();
    /// attributes.Add(Som.UserOC.NickName);
    /// attributes.Add(Som.UserOC.Status);
    /// RequestAttributeValueUpdate(UserObject, attributes);
    /// </code>
    /// </example>
    virtual public bool RequestAttributeValueUpdate<_Type>(HlaObject theObject, List<HlaAttribute> attributes, _Type user_supplied_tag)
    {
      // Convert to IntPtr
      VariableLengthDataWrapper tag = new VariableLengthDataWrapper();
      tag.AddData(user_supplied_tag);

      return (_rtiAmb.requestAttributeValueUpdate(theObject, attributes, tag));
    }
    /// <summary>
    /// HLA13: RequestAttributeValueUpdate (object class)
    /// </summary>
    /// <param name="theClass"></param>
    /// <param name="attributes"></param>
    /// <returns></returns>
    virtual public bool RequestAttributeValueUpdate(HlaObjectClass theClass, List<HlaAttribute> attributes)
    {
      return _rtiAmb.requestAttributeValueUpdate(theClass, attributes);
    }
    /// <summary>
    /// HLA13: RequestAttributeValueUpdate (object)
    /// </summary>
    /// <param name="theObject"></param>
    /// <param name="attributes"></param>
    /// <returns></returns>
    virtual public bool RequestAttributeValueUpdate(HlaObject theObject, List<HlaAttribute> attributes)
    {
      return (_rtiAmb.requestAttributeValueUpdate(theObject, attributes));
    }

    /// <summary>
    /// Registers (create) an HLA object instance. The object handle is assigned by the RTI at the end of a succesfull method call.
    /// </summary>
    /// <param name="theObject">HLA Object to be registered.</param>
    /// <returns>True if method call is succesfull.</returns>
    virtual public bool RegisterHlaObject(HlaObject theObject)
    {
      #region Contracts
      // Preconditions
      //a) The federate is connected to the RTI.
      // This is ensured by the JOINED state
      //b) The federation execution exists.
      Contract.Requires(FederationExecutionState == FederationExecutionStates.FEDEX_EXISTS, " at RegisterHlaObject().");
      //c) The federate is joined to that federation execution.
      Contract.Requires(FederateState.HasFlag(FederateStates.JOINED), " at RegisterHlaObject().");
      //d) The object class is defined in the FDD
      //Contract.Requires(theObject.ClassHandle != 0, " at RegisterHlaObject()."); // Class handle will be 0 if not P/S.
      //e) The joined federate is publishing the object class.
      //Contract.Requires(theObject.Type.ClassPS == PSKind.PublishSubscribe || theObject.Type.ClassPS == PSKind.Publish, " at RegisterHlaObject().");
      //f) If the optional object instance name argument is supplied, that name is reserved and not already coadunated with another object instance.
      //g) Federate save not in progress.
      //h) Federate restore not in progress.

      // Postconditions
      //a) The returned object instance handle is coadunated with the object instance.
      Contract.Ensures(theObject.Handle != 0, " at RegisterHlaObject().");
      //b) The joined federate acquires ownership of the instance attributes that correspond to the currently published class attributes for the specified object class.
      //c) If the optional object instance name argument is supplied, that name is coadunated with the object instance.     
      #endregion

      bool result;
      if (theObject.Name != "")
        result = _rtiAmb.registerObject(theObject, theObject.Name);
      else
        result = _rtiAmb.registerObject(theObject);
      if (result) return true;
      else return false;
    }

    #endregion // Object Management

    #region Ownership Management

    /// <summary>
    /// IEEE1516.1-2010 7.2 and HLA13
    /// </summary>
    /// <remarks>
    /// Releases ownership of a specified set of instance attributes for a specified object instance. The attributes immediately become unowned and are available for acquisition by any federate.
    /// </remarks>
    /// <param name="theObject"></param>
    /// <param name="attributeSet"></param>
    /// <returns></returns>
    virtual public bool UnconditionalAttributeOwnershipDivestiture(HlaObject theObject, List<HlaAttribute> attributeSet)
    {
      #region Contracts
      // Preconditions
      //a) The federate is connected to the RTI.
      //b) The federation execution exists.
      Contract.Requires(FederationExecutionState == FederationExecutionStates.FEDEX_EXISTS, " at AttributeOwnershipAcquisitionIfAvailable().");
      //c) The federate is joined to that federation execution.
      Contract.Requires(FederateState.HasFlag(FederateStates.JOINED), " at AttributeOwnershipAcquisitionIfAvailable().");
      //d) An object instance with the specified designator exists.
      //g) The joined federate knows about the object instance with the specified designator.
      //h) Federate save not in progress.
      //i) Federate restore not in progress.

      // Postconditions
      #endregion

      return _rtiAmb.unconditionalAttributeOwnershipDivestiture(theObject, attributeSet);
    }

    /// <summary>
    /// IEEE1516.1-2010 7.3 
    /// </summary>
    /// <remarks>
    /// Initiates an attempt to release ownership of a specified set of instance-attributes for a specified object instance. 
    /// In the absence of an acquiring federate, the instance-attributes will continue to be owned by the divesting federate.
    /// </remarks>
    /// <param name="theObject"></param>
    /// <param name="attributeSet"></param>
    /// <param name="user_supplied_tag"></param>
    /// <returns></returns>
    virtual public bool NegotiatedAttributeOwnershipDivestiture<_Type>(HlaObject theObject, List<HlaAttribute> attributeSet, _Type user_supplied_tag)
    {
      #region Contracts
      // Preconditions
      //a) The federate is connected to the RTI.
      //b) The federation execution exists.
      Contract.Requires(FederationExecutionState == FederationExecutionStates.FEDEX_EXISTS, " at AttributeOwnershipAcquisitionIfAvailable().");
      //c) The federate is joined to that federation execution.
      Contract.Requires(FederateState.HasFlag(FederateStates.JOINED), " at AttributeOwnershipAcquisitionIfAvailable().");
      //d) An object instance with the specified designator exists.
      //g) The joined federate knows about the object instance with the specified designator.
      //h) Federate save not in progress.
      //i) Federate restore not in progress.

      // Postconditions
      #endregion

      // Convert to IntPtr
      VariableLengthDataWrapper tag = new VariableLengthDataWrapper();
      tag.AddData(user_supplied_tag);
      return _rtiAmb.negotiatedAttributeOwnershipDivestiture(theObject, attributeSet, tag);
    }
    /// <summary>
    /// Racon
    /// </summary>
    /// <remarks>
    /// Initiates an attempt to release ownership of all instance-attributes for a specified object instance. 
    /// In the absence of an acquiring federate, the instance-attributes will continue to be owned by the divesting federate.
    /// </remarks>
    /// <param name="theObject"></param>
    /// <param name="user_supplied_tag"></param>
    /// <returns></returns>
    virtual public bool NegotiatedAttributeOwnershipDivestiture<_Type>(HlaObject theObject, _Type user_supplied_tag)
    {
      #region Contracts
      // Preconditions
      //a) The federate is connected to the RTI.
      //b) The federation execution exists.
      Contract.Requires(FederationExecutionState == FederationExecutionStates.FEDEX_EXISTS, " at AttributeOwnershipAcquisitionIfAvailable().");
      //c) The federate is joined to that federation execution.
      Contract.Requires(FederateState.HasFlag(FederateStates.JOINED), " at AttributeOwnershipAcquisitionIfAvailable().");
      //d) An object instance with the specified designator exists.
      //g) The joined federate knows about the object instance with the specified designator.
      //h) Federate save not in progress.
      //i) Federate restore not in progress.

      // Postconditions
      #endregion

      // Convert to IntPtr
      VariableLengthDataWrapper tag = new VariableLengthDataWrapper();
      tag.AddData(user_supplied_tag);
      return _rtiAmb.negotiatedAttributeOwnershipDivestiture(theObject, theObject.Type.Attributes, tag);
    }
    /// <summary>
    /// HLA13: NegotiatedAttributeOwnershipDivestiture
    /// </summary>
    /// <param name="theObject"></param>
    /// <param name="attributeSet"></param>
    /// <returns></returns>
    virtual public bool NegotiatedAttributeOwnershipDivestiture(HlaObject theObject, List<HlaAttribute> attributeSet)
    {
      return _rtiAmb.negotiatedAttributeOwnershipDivestiture(theObject, attributeSet, theObject.Tag);
    }

    /// <summary>
    /// IEEE1516-2010 7.6
    /// </summary>
    /// <param name="theObject"></param>
    /// <param name="attributeSet"></param>
    /// <param name="user_supplied_tag"></param>
    /// <returns></returns>
    public virtual bool ConfirmDivestiture<_Type>(HlaObject theObject, List<HlaAttribute> attributeSet, _Type user_supplied_tag)
    {
      // Convert to IntPtr
      VariableLengthDataWrapper tag = new VariableLengthDataWrapper();
      tag.AddData(user_supplied_tag);
      return _rtiAmb.confirmDivestiture(theObject, attributeSet, tag);
    }

    /// <summary>
    /// IEEE1516.1-2010 7.8 
    /// </summary>
    /// <remarks>
    /// Initiates an attempt to acquire a specified set of attributes of an object instance. 
    /// </remarks>
    /// <param name="theObject"></param>
    /// <param name="attributeSet"></param>
    /// <param name="user_supplied_tag"></param>
    /// <returns></returns>
    virtual public bool AttributeOwnershipAcquisition<_Type>(HlaObject theObject, List<HlaAttribute> attributeSet, _Type user_supplied_tag)
    {
      #region Contracts
      // Preconditions
      //a) The federate is connected to the RTI.
      //b) The federation execution exists.
      Contract.Requires(FederationExecutionState == FederationExecutionStates.FEDEX_EXISTS, " at AttributeOwnershipAcquisitionIfAvailable().");
      //c) The federate is joined to that federation execution.
      Contract.Requires(FederateState.HasFlag(FederateStates.JOINED), " at AttributeOwnershipAcquisitionIfAvailable().");
      //d) An object instance with the specified designator exists.
      //g) The joined federate knows about the object instance with the specified designator.
      //h) Federate save not in progress.
      //i) Federate restore not in progress.

      // Postconditions
      #endregion

      // Convert to IntPtr
      VariableLengthDataWrapper tag = new VariableLengthDataWrapper();
      tag.AddData(user_supplied_tag);

      return _rtiAmb.attributeOwnershipAcquisition(theObject, attributeSet, tag);
    }
    /// <summary>
    /// Racon
    /// </summary>
    /// <remarks>
    /// Initiates an attempt to acquire all attributes of an object instance. 
    /// </remarks>
    /// <param name="theObject"></param>
    /// <param name="user_supplied_tag"></param>
    /// <returns></returns>
    virtual public bool AttributeOwnershipAcquisition<_Type>(HlaObject theObject, _Type user_supplied_tag)
    {
      #region Contracts
      // Preconditions
      //a) The federate is connected to the RTI.
      //b) The federation execution exists.
      Contract.Requires(FederationExecutionState == FederationExecutionStates.FEDEX_EXISTS, " at AttributeOwnershipAcquisitionIfAvailable().");
      //c) The federate is joined to that federation execution.
      Contract.Requires(FederateState.HasFlag(FederateStates.JOINED), " at AttributeOwnershipAcquisitionIfAvailable().");
      //d) An object instance with the specified designator exists.
      //g) The joined federate knows about the object instance with the specified designator.
      //h) Federate save not in progress.
      //i) Federate restore not in progress.

      // Postconditions
      #endregion

      // Convert to IntPtr
      VariableLengthDataWrapper tag = new VariableLengthDataWrapper();
      tag.AddData(user_supplied_tag);

      return _rtiAmb.attributeOwnershipAcquisition(theObject, theObject.Type.Attributes, tag);
    }
    /// <summary>
    /// HLA13: AttributeOwnershipAcquisition
    /// </summary>
    /// <param name="theObject"></param>
    /// <param name="attributeSet"></param>
    /// <param name="tag"></param>
    /// <returns></returns>
    virtual public bool AttributeOwnershipAcquisition(HlaObject theObject, List<HlaAttribute> attributeSet)
    {
      return _rtiAmb.attributeOwnershipAcquisition(theObject, attributeSet, theObject.Tag);
    }

    /// <summary>
    /// IEEE1516.1-2010 7.9 and HLA13 
    /// </summary>
    /// <remarks>
    /// Initiates an attempt to acquire a set of instanceattributes of an object instance. 
    /// Only instance-attributes that exist in the federation but are currently unowned will be acquired.
    /// </remarks>
    /// <param name="theObject"></param>
    /// <param name="attributeSet"></param>
    /// <returns></returns>
    public virtual bool AttributeOwnershipAcquisitionIfAvailable(HlaObject theObject, List<HlaAttribute> attributeSet)
    {
      #region Contracts
      // Preconditions
      //a) The federate is connected to the RTI.
      //b) The federation execution exists.
      Contract.Requires(FederationExecutionState == FederationExecutionStates.FEDEX_EXISTS, " at AttributeOwnershipAcquisitionIfAvailable().");
      //c) The federate is joined to that federation execution.
      Contract.Requires(FederateState.HasFlag(FederateStates.JOINED), " at AttributeOwnershipAcquisitionIfAvailable().");
      //d) An object instance with the specified designator exists.
      //e) The joined federate knows about the object instance with the specified designator.
      //i) Federate save not in progress.
      //j) Federate restore not in progress.

      // Postconditions
      #endregion

      return _rtiAmb.attributeOwnershipAcquisitionIfAvailable(theObject, attributeSet);
    }

    /// <summary>
    /// IEEE1516-2010 7.12
    /// </summary>
    /// <param name="theObject">Object instance designator</param>
    /// <param name="attributeSet">Set of attribute designators for which the joined federate is unwilling to divest ownership</param>
    /// <returns></returns>
    public virtual bool AttributeOwnershipReleaseDenied(HlaObject theObject, List<HlaAttribute> attributeSet)
    {
      return _rtiAmb.attributeOwnershipReleaseDenied(theObject, attributeSet);
    }

    /// <summary>
    /// IEEE1516-2010 7.13
    /// </summary>
    /// <param name="theObject">Object instance designator</param>
    /// <param name="attributeSet">Set of attribute designators for which the joined federate is willing to divest ownership.</param>
    /// <param name="attributesDivested">Set of attribute designators for which ownership has actually been divested. This is filled by the RTI.</param>
    /// <returns></returns>
    public virtual bool AttributeOwnershipDivestitureIfWanted(HlaObject theObject, List<HlaAttribute> attributeSet, out List<HlaAttribute> attributesDivested)
    {
      return _rtiAmb.attributeOwnershipDivestitureIfWanted(theObject, attributeSet, out attributesDivested);
    }

    /// <summary>
    /// IEEE1516.1-2010 7.14 and HLA13
    /// </summary>
    /// <remarks>
    /// Cancels a previously requested negotiated ownership divestiture for a specified set of instance-attributes of a specified object instance.
    /// </remarks>
    /// <param name="theObject"></param>
    /// <param name="attributes"></param>
    /// <returns></returns>
    virtual public bool CancelNegotiatedAttributeOwnershipDivestiture(HlaObject theObject, List<HlaAttribute> attributes)
    {
      #region Contracts
      // Preconditions
      //a) The federate is connected to the RTI.
      //b) The federation execution exists.
      Contract.Requires(FederationExecutionState == FederationExecutionStates.FEDEX_EXISTS, " at attributeOwnershipReleaseResponse().");
      //c) The federate is joined to that federation execution.
      Contract.Requires(FederateState.HasFlag(FederateStates.JOINED), " at attributeOwnershipReleaseResponse().");
      //d) An object instance with the specified designator exists.
      //g) The joined federate knows about the object instance with the specified designator.
      //h) Federate save not in progress.
      //i) Federate restore not in progress.

      // Postconditions
      #endregion

      return _rtiAmb.cancelNegotiatedAttributeOwnershipDivestiture(theObject, attributes);
    }

    /// <summary>
    /// IEEE1516.1-2010 7.15 and HLA13
    /// </summary>
    /// <remarks>
    /// Requests the cancellation of a previously requested ownership acquisition for a specified set of instance-attributes of a specified object instance.
    /// </remarks>
    /// <param name="theObject"></param>
    /// <param name="attributes"></param>
    /// <returns></returns>
    virtual public bool CancelAttributeOwnershipAcquisition(HlaObject theObject, List<HlaAttribute> attributes)
    {
      #region Contracts
      // Preconditions
      //a) The federate is connected to the RTI.
      //b) The federation execution exists.
      Contract.Requires(FederationExecutionState == FederationExecutionStates.FEDEX_EXISTS, " at AttributeOwnershipAcquisitionIfAvailable().");
      //c) The federate is joined to that federation execution.
      Contract.Requires(FederateState.HasFlag(FederateStates.JOINED), " at AttributeOwnershipAcquisitionIfAvailable().");
      //d) An object instance with the specified designator exists.
      //g) The joined federate knows about the object instance with the specified designator.
      //h) Federate save not in progress.
      //i) Federate restore not in progress.

      // Postconditions
      #endregion

      return _rtiAmb.cancelAttributeOwnershipAcquisition(theObject, attributes);
    }

    /// <summary>
    /// IEEE1516.1-2010 7.17 and HLA13 
    /// </summary>
    /// <remarks>
    /// Determines which federate (if any) holds the attribute ownership token for a given instance-attribute.
    /// </remarks>
    /// <param name="theObject"></param>
    /// <param name="attribute"></param>
    /// <returns></returns>
    virtual public bool QueryAttributeOwnership(HlaObject theObject, HlaAttribute attribute)
    {
      #region Contracts
      // Preconditions
      //a) The federate is connected to the RTI.
      //b) The federation execution exists.
      Contract.Requires(FederationExecutionState == FederationExecutionStates.FEDEX_EXISTS, " at QueryAttributeOwnership().");
      //c) The federate is joined to that federation execution.
      Contract.Requires(FederateState.HasFlag(FederateStates.JOINED), " at QueryAttributeOwnership().");
      //d) An object instance with the specified designator exists.
      //g) The joined federate knows about the object instance with the specified designator.
      //h) Federate save not in progress.
      //i) Federate restore not in progress.

      // Postconditions
      #endregion

      return _rtiAmb.queryAttributeOwnership(theObject, attribute);
    }

    /// <summary>
    /// IEEE1516.1-2010 7.19 and HLA13 
    /// </summary>
    /// <remarks>
    /// Queries the LRC to determine whether a specified instance-attribute of a specified object instance is currently owned by the local federate.
    /// </remarks>
    /// <param name="theObject"></param>
    /// <param name="attribute"></param>
    /// <returns></returns>
    virtual public bool IsAttributeOwnedByFederate(HlaObject theObject, HlaAttribute attribute)
    {
      #region Contracts
      // Preconditions
      //a) The federate is connected to the RTI.
      //b) The federation execution exists.
      Contract.Requires(FederationExecutionState == FederationExecutionStates.FEDEX_EXISTS, " at attributeOwnershipReleaseResponse().");
      //c) The federate is joined to that federation execution.
      Contract.Requires(FederateState.HasFlag(FederateStates.JOINED), " at attributeOwnershipReleaseResponse().");
      //d) An object instance with the specified designator exists.
      //g) The joined federate knows about the object instance with the specified designator.
      //h) Federate save not in progress.
      //i) Federate restore not in progress.

      // Postconditions
      #endregion

      return _rtiAmb.isAttributeOwnedByFederate(theObject, attribute);
    }

    /// <summary>
    /// HLA13
    /// </summary>
    /// <remarks>
    /// Releases ownership of a set of instance-attributes for a specified instance, 
    /// in compliance with a requestAttribute-OwnershipRelease() request. HLA-13 specific?
    /// </remarks>
    virtual public bool AttributeOwnershipReleaseResponse(HlaObject theObject, List<HlaAttribute> attributes)
    {
      #region Contracts
      // Preconditions
      //a) The federate is connected to the RTI.
      //b) The federation execution exists.
      Contract.Requires(FederationExecutionState == FederationExecutionStates.FEDEX_EXISTS, " at attributeOwnershipReleaseResponse().");
      //c) The federate is joined to that federation execution.
      Contract.Requires(FederateState.HasFlag(FederateStates.JOINED), " at attributeOwnershipReleaseResponse().");
      //d) An object instance with the specified designator exists.
      //g) The joined federate knows about the object instance with the specified designator.
      //h) Federate save not in progress.
      //i) Federate restore not in progress.

      // Postconditions
      #endregion

      return _rtiAmb.attributeOwnershipReleaseResponse(theObject, attributes);
    }

    #endregion // Ownership Management

    #region Time Management

    /// <summary>
    /// IEEE1516.1-2010: 8.2 Enable Time Regulation
    /// </summary>
    /// <param name="lookahead">the lookahead to use for the federate</param>
    /// <returns></returns>
    virtual public bool EnableTimeRegulation(double lookahead)
    {
      //precondition: lookahead must be non-negative
      if (_rtiAmb.enableTimeRegulation(lookahead)) return true;
      else return false;
    }

    /// <summary>
    /// HLA13 - Enable Time Regulation. parameters are seconds
    /// </summary>
    /// <param name="federateTime">the minimum logical time to set the federate’s logical time to when turning regulation on</param>
    /// <param name="lookahead">the lookahead to use for the federate</param>
    /// <returns></returns>
    virtual public bool EnableTimeRegulation(double federateTime, double lookahead)
    {
      if (_rtiAmb.enableTimeRegulation(federateTime, lookahead)) return true;
      else return false;
    }

    /// <summary>
    /// IEEE1516.1-2010: 8.4 Disable Time Regulation
    /// </summary>
    virtual public bool DisableTimeRegulation()
    {
      if (_rtiAmb.disableTimeRegulation()) return true;
      else return false;
    }

    /// <summary>
    /// IEEE1516.1-2010: 8.5 Enable Time Constrained
    /// </summary>
    virtual public bool EnableTimeConstrained()
    {
      if (_rtiAmb.enableTimeConstrained()) return true;
      else return false;
    }

    /// <summary>
    /// IEEE1516.1-2010: 8.7 Disable Time Constrained
    /// </summary>
    /// <returns></returns>
    virtual public bool DisableTimeConstrained()
    {
      if (_rtiAmb.disableTimeConstrained()) return true;
      else return false;
    }

    /// <summary>
    /// IEEE1516.1-2010: 8.10 Next Message Request
    /// </summary>
    /// <param name="logicalTime"></param>
    /// <returns></returns>
    public virtual bool nextMessageRequest(double logicalTime)
    {
      if (_rtiAmb.nextMessageRequest(logicalTime)) return true;
      else return false;
    }

    /// <summary>
    /// HLA13: nextEventRequest
    /// </summary>
    /// <param name="time"></param>
    /// <returns></returns>
    virtual public bool NextEventRequest(double time)
    {
      if (_rtiAmb.nextEventRequest(time)) return true;
      else return false;
    }

    /// <summary>
    /// IEEE1516.1-2010: 8.11 Next Message Request Available
    /// </summary>
    /// <param name="logicalTime"></param>
    /// <returns></returns>
    public virtual bool nextMessageRequestAvailable(double logicalTime)
    {
      if (_rtiAmb.nextMessageRequestAvailable(logicalTime)) return true;
      else return false;
    }

    /// <summary>
    /// HLA13: nextEventRequestAvailable
    /// </summary>
    /// <param name="time"></param>
    /// <returns></returns>
    virtual public bool NextEventRequestAvailable(double time)
    {
      if (_rtiAmb.nextEventRequestAvailable(time)) return true;
      else return false;
    }

    /// <summary>
    /// IEEE1516.1-2010: 8.12 Flush Queue Request
    /// </summary>
    /// <param name="time"></param>
    /// <returns></returns>
    virtual public bool FlushQueueRequest(double time)
    {
      if (_rtiAmb.flushQueueRequest(time)) return true;
      else return false;
    }

    /// <summary>
    /// IEEE1516.1-2010: 8.14 Enable Asynchronous Delivery
    /// </summary>
    /// <returns></returns>
    virtual public bool EnableAsynchronousDelivery()
    {
      if (_rtiAmb.enableAsynchronousDelivery()) return true;
      else return false;
    }

    /// <summary>
    /// IEEE1516.1-2010: 8.15 Disable Asynchronous Delivery
    /// </summary>
    /// <returns></returns>
    virtual public bool DisableAsynchronousDelivery()
    {
      if (_rtiAmb.disableAsynchronousDelivery()) return true;
      else return false;
    }

    /// <summary>
    /// IEEE1516.1-2010: 8.23 Change Attribute Order Type
    /// </summary>
    /// <param name="theObject"></param>
    /// <param name="attributes"></param>
    /// <param name="type"></param>
    /// <returns></returns>
    virtual public bool ChangeAttributeOrderType(HlaObject theObject, List<HlaAttribute> attributes, OrderType type)
    {
      if (_rtiAmb.changeAttributeOrderType(theObject, attributes, (uint)type)) return true;
      else return false;
    }

    /// <summary>
    /// IEEE1516.1-2010: 8.24 Change Interaction Order Type
    /// </summary>
    /// <param name="ic"></param>
    /// <param name="type"></param>
    /// <returns></returns>
    virtual public bool ChangeInteractionOrderType(HlaInteractionClass ic, OrderType type)
    {
      if (_rtiAmb.changeInteractionOrderType(ic, (uint)type)) return true;
      else return false;
    }



    /// <summary>
    /// IEEE1516.1-2010: 8.19 Modify Lookahead
    /// </summary>
    /// <param name="lookahead">requested lookahead (lookahead is a time interval)</param>
    /// <returns></returns>
    virtual public bool ModifyLookahead(double lookahead)
    {
      if (_rtiAmb.modifyLookahead(lookahead)) return true;
      else return false;
    }

    /// <summary>
    /// IEEE1516.1-2010: 8.20 Query Lookahead
    /// </summary>
    /// <returns></returns>
    virtual public double QueryLookahead()
    {
      return _rtiAmb.queryLookahead();
    }

    /// <summary>
    /// IEEE1516.1-2010: 8.17 Query Logical Time
    /// </summary>
    /// <returns>The invoking joined federate’s current logical time.</returns>
    virtual public double QueryLogicalTime()
    {
      return _rtiAmb.queryLogicalTime();
    }

    /// <summary>
    /// HLA13 - Query Federate Time
    /// </summary>
    virtual public double QueryFederateTime()
    {
      return _rtiAmb.queryFederateTime();
    }

    /// <summary>
    /// IEEE1516.1 2010 - 8.16 Query Greatest Available Logical Time (GALT)
    /// </summary>
    /// <param name="Galt">(Optional) current value of invoking joined federate’s GALT</param>
    /// <returns>GALT definition indicator returns True if GALT is defined</returns>
    public virtual bool queryGALT(out double Galt)
    {
      return _rtiAmb.queryGALT(out Galt);
    }

    /// <summary>
    /// IEEE1516.1-2010: 8.16 Query Greatest Available Logical Time (GALT) - with optional GALT value
    /// </summary>
    /// <returns>GALT definition indicator returns True if GALT is defined</returns>
    public virtual bool queryGALT()
    {
      double Galt = 0;
      bool res = _rtiAmb.queryGALT(out Galt);
      return res;
    }

    /// <summary>
    /// HLA13 - QueryLBTS = QueryGALT
    /// </summary>
    virtual public double QueryLBTS()
    {
      return _rtiAmb.queryLBTS();
    }

    /// <summary>
    /// IEEE1516.1-2010: 8.18 Query List Incoming Time Stamp (LIST)
    /// </summary>
    /// <param name="Lits">Optional current value of invoking joined federate’s LITS</param>
    /// <returns>LITS definition indicator returns True if LIST is defined</returns>
    public virtual bool QueryLITS(out double Lits)
    {
      bool res = _rtiAmb.queryLITS(out Lits);
      return res;
    }

    /// <summary>
    /// IEEE1516.1-2010: 8.18 Query List Incoming Time Stamp (LIST) - with optional LITS value
    /// </summary>
    /// <returns>LITS definition indicator returns True if LIST is defined</returns>
    public virtual bool QueryLITS()
    {
      double Lits = 0;
      bool res = _rtiAmb.queryLITS(out Lits);
      return res;
    }

    /// <summary>
    /// HLA13 - QueryMinNextEventTime = queryLITS
    /// </summary>
    virtual public double QueryMinNextEventTime()
    {
      return _rtiAmb.queryMinNextEventTime();
    }

    /// <summary>
    /// IEEE1516.1-2010: 8.21 Retracts the message with specified retraction handle.
    /// </summary>
    /// <param name="retraction"></param>
    /// <returns></returns>
    virtual public bool Retract(MessageRetraction retraction)
    {
      if (_rtiAmb.retract(retraction)) return true;
      else return false;
    }

    /// <summary>
    /// IEEE1516.1-2010: 8.8 Time Advance Request
    /// </summary>
    /// <param name="time">the logical time</param>
    /// <returns></returns>
    virtual public bool TimeAdvanceRequest(double time)
    {
      if (_rtiAmb.timeAdvanceRequest(time)) return true;
      else return false;
    }

    /// <summary>
    /// IEEE1516.1-2010: 8.9 Time Advance Request Available
    /// </summary>
    /// <param name="time">the logical time</param>
    /// <returns></returns>
    virtual public bool TimeAdvanceRequestAvailable(double time)
    {
      if (_rtiAmb.timeAdvanceRequestAvailable(time)) return true;
      else return false;
    }

    #endregion // Time Management

    #region Supporting Services
    /// <summary>
    /// IEEE1516.1-2010 10.4: getFederateHandle
    /// </summary>
    /// <param name="federateName"></param>
    /// <returns></returns>
    public virtual uint GetFederateHandle(string federateName)
    {
      return _rtiAmb.getFederateHandle(federateName);
    }
    /// <summary>
    /// IEEE1516.1-2010 10.5: getFederateName
    /// </summary>
    /// <param name="federateHandle"></param>
    /// <returns></returns>
    public virtual string GetFederateName(uint federateHandle)
    {
      return _rtiAmb.getFederateName(federateHandle);
    }

    /// <summary>
    /// Racon: getAllDimensionHandles
    /// </summary>
    /// <returns></returns>
    public virtual void GetAllDimensionHandles()
    {
      foreach (var dimension in _som.Dimensions)
      {
        dimension.Handle = GetDimensionHandle(dimension.Name);
      }
    }

    /// <summary>
    /// IEEE1516.1-2010 10.25: getDimensionHandle
    /// </summary>
    /// <param name="name">Dimension name</param>
    /// <returns></returns>
    public virtual uint GetDimensionHandle(string name)
    {
      return _rtiAmb.getDimensionHandle(name);
    }

    /// <summary>
    /// IEEE1516.1-2010 10.26: getDimensionName
    /// </summary>
    /// <param name="handle">Dimension handle</param>
    /// <returns></returns>
    public virtual string GetDimensionName(uint handle)
    {
      return _rtiAmb.getDimensionName(handle);
    }

    /// <summary>
    /// IEEE1516.1-2010 10.30: setRangeBounds
    /// </summary>
    /// <param name="regionHandle"></param>
    /// <param name="dimensionHandle"></param>
    /// <param name="lowerBound"></param>
    /// <param name="upperBound"></param>
    public virtual void SetRangeBounds(uint regionHandle, uint dimensionHandle, uint lowerBound, uint upperBound)
    {
      _rtiAmb.setRangeBounds(regionHandle, dimensionHandle, lowerBound, upperBound);
    }
    /// <summary>
    /// IEEE1516.1-2010 10.35: Enable Attribute Relevance Advisory Switch enables the generation of the Attribute Relevance Advisory Switch service advisory 
    /// </summary>
    virtual public bool EnableAttributeRelevanceAdvisorySwitch()
    {
      if (_rtiAmb.enableAttributeRelevanceAdvisorySwitch()) return true;
      else return false;
    }

    /// <summary>
    /// IEEE1516.1-2010 10.37: EnableAttributeScopeAdvisorySwitch
    /// </summary>
    virtual public bool EnableAttributeScopeAdvisorySwitch()
    {
      if (_rtiAmb.enableAttributeScopeAdvisorySwitch()) return true;
      else return false;
    }

    /// <summary>
    /// IEEE1516.1-2010 10.39: EnableInteractionRelevanceAdvisorySwitch
    /// </summary>
    virtual public bool EnableInteractionRelevanceAdvisorySwitch()
    {
      if (_rtiAmb.enableInteractionRelevanceAdvisorySwitch()) return true;
      else return false;
    }

    /// <summary>
    /// Enable Object Class Relevance Advisory Switch enables the generation of the Start/Stop Registration For Object Class service advisory 
    /// </summary>
    virtual public bool EnableObjectClassRelevanceAdvisorySwitch()
    {
      if (_rtiAmb.enableObjectClassRelevanceAdvisorySwitch()) return true;
      else return false;
    }

    /// <summary>
    /// Disable Attribute Relevance Advisory Switch disables the generation of the Attribute Relevance Advisory Switch service advisory
    /// </summary>
    virtual public bool DisableAttributeRelevanceAdvisorySwitch()
    {
      if (_rtiAmb.disableAttributeRelevanceAdvisorySwitch()) return true;
      else return false;
    }

    /// <summary>
    /// DisableAttributeScopeAdvisorySwitch
    /// </summary>
    virtual public bool DisableAttributeScopeAdvisorySwitch()
    {
      if (_rtiAmb.disableAttributeScopeAdvisorySwitch()) return true;
      else return false;
    }

    /// <summary>
    /// Disable Object Class Relevance Advisory Switch disables the generation of the Start/Stop Registration For Object Class service advisory 
    /// </summary>
    virtual public bool DisableObjectClassRelevanceAdvisorySwitch()
    {
      if (_rtiAmb.disableObjectClassRelevanceAdvisorySwitch()) return true;
      else return false;
    }

    /// <summary>
    /// DisableInteractionRelevanceAdvisorySwitch
    /// </summary>
    virtual public bool DisableInteractionRelevanceAdvisorySwitch()
    {
      if (_rtiAmb.disableInteractionRelevanceAdvisorySwitch()) return true;
      else return false;
    }

    /// <summary>
    /// Evoke Callback
    /// <param name="approximateMinimumTimeInSeconds">this service invocation shall wait for the duration indicated by this argument. Default is 0.01 sec (1 msec)</param>
    /// </summary>
    virtual public void EvokeCallback(double approximateMinimumTimeInSeconds = 0.01)
    {
      _rtiAmb.evokeCallback(approximateMinimumTimeInSeconds);
    }

    /// <summary>
    /// Instructs the RTI that the invoking federate is prepared to receive multiple federate callbacks.The service shall continue to process available callbacks until the minimum specified wall-clock time. At that wall-clock time, if there are no additional callbacks to be delivered to the federate, the service shall complete. If, after the minimum specified wall-clock time, there continue to be callbacks, the RTI shall continue to deliver those callbacks until the maximum specified wall-clock time is exceeded.
    /// <param name="approximateMinimumTimeInSeconds">Min amount of wallclock time. </param>
    /// <param name="approximateMaximumTimeInSeconds">Max amount of wallclock time.</param>
    /// </summary>
    virtual public void EvokeMultipleCallbacks(double approximateMinimumTimeInSeconds, double approximateMaximumTimeInSeconds)
    {
      _rtiAmb.evokeMultipleCallbacks(approximateMinimumTimeInSeconds, approximateMaximumTimeInSeconds);
    }
    /// <summary>
    /// Tick() is alias for Evoke Callback
    /// </summary>
    virtual public void Tick()
    {
      EvokeCallback();
    }

    /// <summary>
    /// Tick(min, max) is alias for Evoke Multiple Callbacks
    /// <param name="minimum">the minimum time interval (in wall clock seconds) to spend in tick()</param>
    /// <param name="maximum">the maximum time interval (in wall clock seconds) after which tick() will not begin execution of any additional processing</param>
    /// </summary>
    virtual public void Tick(double minimum, double maximum)
    {
      EvokeMultipleCallbacks(minimum, maximum);
    }
    #endregion // Supporting Services

    #endregion // RtiAmb Function Wrappers

    #endregion // Methods
  }
}
